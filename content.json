{"meta":{"title":"—幻想郷に、遊ぶがいい—","subtitle":null,"description":"Gensokyo","author":"i-cookie","url":"http://yoursite.com","root":"/"},"pages":[{"title":"10.22比赛","date":"2019-10-21T16:00:00.000Z","updated":"2019-10-23T08:24:12.000Z","comments":true,"path":"2019-10-22-10.22比赛.html","permalink":"http://yoursite.com/2019-10-22-10.22比赛.html","excerpt":"","text":"T1题意给定一张无向图,在任意时刻,如果与图中的一个点u相连的边中只有一条边是白色的,那么这条边也会被染黑.开始时图中的边都是白的,问至少染几条边能使得整张图都变黑 题解实际上把一条边染黑相当于删掉.我们发现如果图中有一个环,那么在不染环上的边的情况下它最后一定会剩下来.所以如果无环就可以使得所有边都自动删除.无环意味着这张图成为了森林(原图不一定连通).所以我们通过并查集得到图中有多少联通块就可以解决这道题了. T2题意 定义集合 S(t) 表示所有正整数的 t 次幂组成的集合,现在给出q个询问,每个询问指定k个数$n_1,n_2,n_3…n_k$.求出不可重集$\\bigcup_{i=1}^{k}S(n_i)$中第m小的数字. 题解首先来考虑二分答案,我们二分一个m表示并集中有多少个数$\\le $m.考虑容斥,枚举一个s是{n1,n2…nk}的子集","author":"i-cookie"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-10-09T03:24:12.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"[i-cookie's blog] 与&nbsp; i-cookie&nbsp; （ 您好（こんにちは） ） 对话中... bot_ui_ini()"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-08-27T23:07:22.000Z","comments":false,"path":"client/index.html","permalink":"http://yoursite.com/client/index.html","excerpt":"","text":"直接下载 or 扫码下载："},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-08-27T23:07:22.000Z","comments":false,"path":"bangumi/index.html","permalink":"http://yoursite.com/bangumi/index.html","excerpt":"","text":""},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-08-27T23:07:22.000Z","comments":true,"path":"comment/index.html","permalink":"http://yoursite.com/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-08-27T23:07:22.000Z","comments":false,"path":"donate/index.html","permalink":"http://yoursite.com/donate/index.html","excerpt":"","text":""},{"title":"=奆佬通讯簿=","date":"2019-10-09T02:00:00.000Z","updated":"2019-10-10T11:39:32.000Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-08-27T23:07:22.000Z","comments":false,"path":"lab/index.html","permalink":"http://yoursite.com/lab/index.html","excerpt":"","text":"sakura主题balabala"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-08-27T23:07:22.000Z","comments":false,"path":"music/index.html","permalink":"http://yoursite.com/music/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-09-22T08:38:22.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-08-27T23:07:22.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"http://yoursite.com/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-08-27T23:07:22.000Z","comments":true,"path":"rss/index.html","permalink":"http://yoursite.com/rss/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-08-27T23:07:22.000Z","comments":false,"path":"video/index.html","permalink":"http://yoursite.com/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }"}],"posts":[{"title":"=大事记=","slug":"大事记","date":"2333-12-31T15:59:59.000Z","updated":"2021-09-12T08:50:39.268Z","comments":true,"path":"2333/12/31/大事记/","link":"","permalink":"http://yoursite.com/2333/12/31/大事记/","excerpt":"","text":"$\\text{1/12/2018 洛谷200AC祭}$ $\\text{5/12/2018 NOIP2018提高组一等奖获得}$ $\\text{6/3/2019 洛谷300AC祭}$ $\\text{20/8/2019 个人博客开通}$ $\\text{8/9/2019 洛谷400AC祭}$ $\\text{23/9/2019 luogu首篇题解通过审核}$ $\\text{3/11/2019 洛谷500AC祭}$ $\\text{16/12/2019 CSP-S2019一等奖获得}$ $\\text{10/7/2021 高考结束，博客重启}$ $\\qquad \\qquad \\qquad =\\overline{\\underline{|To\\ Be\\ Continued|}}=&gt;$","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[],"author":"i-cookie"},{"title":"One Word Board","slug":"签名版","date":"2022-05-23T04:32:00.000Z","updated":"2022-05-23T04:34:12.260Z","comments":true,"path":"2022/05/23/签名版/","link":"","permalink":"http://yoursite.com/2022/05/23/签名版/","excerpt":"","text":"这里是签名版，随机乱写一些东西什么计算机图形学啊，我不懂啊！","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[],"author":"i-cookie"},{"title":"P1736 创意吃鱼法","slug":"2019-11-9-P1736-创意吃鱼法","date":"2019-11-08T16:00:00.000Z","updated":"2019-11-09T11:47:20.000Z","comments":true,"path":"2019/11/09/2019-11-9-P1736-创意吃鱼法/","link":"","permalink":"http://yoursite.com/2019/11/09/2019-11-9-P1736-创意吃鱼法/","excerpt":"","text":"蒟蒻在DP之路上求索着 题目:传送门题目描述回到家中的猫猫把三桶鱼全部转移到了她那长方形大池子中，然后开始思考：到底要以何种方法吃鱼呢（猫猫就是这么可爱，吃鱼也要想好吃法 ^_*）。她发现，把大池子视为01矩阵（0表示对应位置无鱼，1表示对应位置有鱼）有助于决定吃鱼策略。 在代表池子的01矩阵中，有很多的正方形子矩阵，如果某个正方形子矩阵的某条对角线上都有鱼，且此正方形子矩阵的其他地方无鱼，猫猫就可以从这个正方形子矩阵“对角线的一端”下口，只一吸，就能把对角线上的那一队鲜鱼吸入口中。 猫猫是个贪婪的家伙，所以她想一口吃掉尽量多的鱼。请你帮猫猫计算一下，她一口下去，最多可以吃掉多少条鱼？ 数据范围对于所有数据,$n,m\\le 2500$ 题解这道题的要求非常特殊,是要求出最大的满足”只有对角线上全是1,其他部分都是0”的最大的正方形.与[ZJOI2007]棋盘制作类似.通常这种矩阵类的DP,我们都会设$f[i][j]$表示在某个坐标时的状态.然而这题有一个问题,那就是每当我们进行一行或者一列,我们都要求:除了$(i,j)$外该行/列都是0.这不是一个直接就能求出来的量.但是我们发现由于一次只会推进一格,我们可以初始化这个量. 先求左上-右下对角线的值.我们设$l[i][j]$表示从$(i,j)$往左最长连续多少个0,设$u[i][j]$表示从$(i,j)$向上最长连续多少个0.这样我们在更新状态的时候就可以使用现成的信息了. 然后就是状态.设$f[i][j]$表示以点$(i,j)$为右下角的最大的满足题意的正方形的边长.因为边长和主对角线的格数是一样的.根据题意,很显然的一点是,只有$b[i][j]$(b数组表示池塘)为1的时候才有答案.那么我们怎么转移呢?题目中要求的是正方形,所以如果向上延申的0的个数&lt;向左的,那显然只能按照小的那个来(木桶效应).其次我们还要考虑是从什么状态转移过来的.显然是从左上方延长对角线来的.所以我们要从三者中取最小的(同样是因为木桶效应).也就是:$$f[i][j]=min(f[i-1][j-1], min(l[i][j],u[i][j]))+1$$这就是左上-右下对角线的求法.对于右上-左下对角线我们只需要从右上角开始预处理一个r数组,其他的类似即可. 代码: int b[N][N], n, m, l[N][N], u[N][N], r[N][N], f[N][N], ans; int main() { read(n), read(m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) read(b[i][j]);//读入 for (int i = 1; i &lt;= n; ++i) b[i][0] = 1, b[i][m + 1] = 1;//为了防止多记录0的数量,把边界标记为1 for (int j = 1; j &lt;= m; ++j) b[0][j] = 1, b[n + 1][j] = 1; for (int i = 1; i &lt;= n; ++i) {//处理l数组和u数组 for (int j = 1; j &lt;= m; ++j) { if (b[i - 1][j] == 0) u[i][j] = u[i - 1][j] + 1; if (b[i][j - 1] == 0) l[i][j] = l[i][j - 1] + 1; } } for (int i = 1; i &lt;= n; ++i)//因为顺序原因单独处理r数组 for (int j = m; j &gt;= 1; --j) if (b[i][j + 1] == 0) r[i][j] = r[i][j + 1] + 1; for (int i = 1; i &lt;= n; ++i) {//状态转移 for (int j = 1; j &lt;= m; ++j) { if (b[i][j] != 1) continue;//判断当前位置是否合法 f[i][j] = 1; if (b[i - 1][j - 1] != 1) continue; f[i][j] = min(f[i - 1][j - 1], min(l[i][j], u[i][j])) + 1; ans = max(ans, f[i][j]); } } memset(f, 0, sizeof(f)); for (int i = 1; i &lt;= n; ++i) {//处理右上-左下对角线 for (int j = m; j &gt;= 1; --j) { if (b[i][j] != 1) continue; f[i][j] = 1; if (b[i - 1][j + 1] != 1) continue; f[i][j] = min(f[i - 1][j + 1], min(r[i][j], u[i][j])) + 1; ans = max(ans, f[i][j]);//两种答案取较大值 } } cout &lt;&lt; ans &lt;&lt; endl; return 0; }","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}],"author":"i-cookie"},{"title":"背包状态设置——P1156 垃圾陷阱","slug":"2019-11-7-背包状态设置——P1156-垃圾陷阱","date":"2019-11-06T16:00:00.000Z","updated":"2019-11-07T13:34:06.000Z","comments":true,"path":"2019/11/07/2019-11-7-背包状态设置——P1156-垃圾陷阱/","link":"","permalink":"http://yoursite.com/2019/11/07/2019-11-7-背包状态设置——P1156-垃圾陷阱/","excerpt":"","text":"蒟蒻在DP之路上求索着 题目:传送门问题描述卡门――农夫约翰极其珍视的一条Holsteins奶牛――已经落了到“垃圾井”中。“垃圾井”是农夫们扔垃圾的地方，它的深度为$D(2 \\le D \\le 100)$英尺。 卡门想把垃圾堆起来，等到堆得与井同样高时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。 每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。 假设卡门预先知道了每个垃圾扔下的时间$t(0&lt; t \\le 1000)$，以及每个垃圾堆放的高度$h(1 \\le h \\le 25)$和吃进该垃圾能维持生命的时间$f(1 \\le f \\le 30)$，要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续10小时的能量，如果卡门$10$小时内没有进食，卡门就将饿死。 数据范围垃圾数$G\\le 100$,每个垃圾被投放的时间$0&lt;T\\le 1000$,每个垃圾能维持卡门的生命时间$0&lt;F\\le 30$.每个垃圾能垫高的高度$0&lt;H\\le 25$. 题解题目中有很多量,时间,生命值,高度,垃圾的个数.那么我们应该怎么设计状态呢?看到题目要求我们求时间,那么我们可以设$f[i][j]$表示一个有关i和j的状态所需的最小时间.但是我们发现剩下的状态有3个,而再加一维显然空间是撑不住的,那怎么办呢?我们必须想办法去掉一个变量. 我们发现,等待垃圾时的时间是不必要的,同时我们也没有必要把垃圾先留着,只需要在它被投放的时候选择怎么处理它.所以我们可以把时间这一维隐含在垃圾中,而没有必要对每个时间点做很多讨论和转移.现在我们有3个变量:垃圾,高度,生命值.对于每个垃圾,我们可以选择用来增加高度(不吃)或者增加生命值(吃),由这个讨论我们发现这是一个背包模型,因此我们选择前i个垃圾作为第一维,那么谁来做第二维呢? 看起来能不能出去和高度有更大的关系,所以我们可以尝试让生命值来做第二维,高度做数组的内容,这样高度足够时就判定有解.也就是设$f[i][j]$表示现在到了第i个垃圾,生命值为j时的最大高度.转移方程如下:$$f[i][j] = max(f[i-1][j]+h[i],f[i-1][j-hp[i]])$$最后进行答案的选择即可.写出来我们发现,生命值不仅会随着吃垃圾而增加,也会随着时间而减少,这时就对边界的判定产生了一些不便之处.那么我们试试用单调不下降的高度来作为第二维?$$f[i][j]=max(f[i-1][j-h[i]],f[i-1][j]+hp[i])$$我们发现这样也是对的,而且不必担心奇怪的边界问题. 代码: #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int n, h, f[105][3500]; struct node { int t, addhp, hight; }r[105]; inline bool cmp(node x, node y) { return x.t &lt; y.t; } int main() { ios::sync_with_stdio(false); cin &gt;&gt; h &gt;&gt; n; int tot = 0; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; r[i].t &gt;&gt; r[i].addhp &gt;&gt; r[i].hight, tot += r[i].addhp; sort(r + 1, r + 1 + n, cmp); memset(f, -64, sizeof(f)); f[0][0] = 10, r[0].t = 0; for(int i = 1; i &lt;= n; i++) { for(int j = h; j &gt;= 0; j--) { if (f[i - 1][j] &lt; r[i].t - r[i - 1].t)continue;//不能从死亡状态转移过来 if(j + r[i].hight &gt;= h) {//如果出去了就直接输出这个垃圾被投放的时间 cout &lt;&lt; r[i].t &lt;&lt; endl; return 0; } f[i][j+r[i].hight] = max(f[i][j+r[i].hight], f[i-1][j]-(r[i].t-r[i-1].t)); f[i][j] = max(f[i - 1][j]+r[i].addhp-(r[i].t-r[i-1].t), f[i][j]); } } int maxlive = -100; for(int i = 1; i &lt;= n; i++) maxlive = max(maxlive, f[i][0] + r[i].t);//取最长生命 cout &lt;&lt; maxlive &lt;&lt; endl; return 0; }","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}],"author":"i-cookie"},{"title":"P1108 低价购买","slug":"2019-10-31-P1108-低价购买","date":"2019-10-30T16:00:00.000Z","updated":"2019-10-31T12:50:36.000Z","comments":true,"path":"2019/10/31/2019-10-31-P1108-低价购买/","link":"","permalink":"http://yoursite.com/2019/10/31/2019-10-31-P1108-低价购买/","excerpt":"","text":"蒟蒻在DP之路上求索着 题目:传送门题目描述“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买；再低价购买”。每次你购买一支股票,你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价($2^{16}$范围内的正整数)，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买；再低价购买”的原则。写一个程序计算最大购买次数。 这里是某支股票的价格清单： 日期 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 价格 68, 69, 54, 64, 68, 64, 70, 67, 78, 62, 98, 87 最优秀的投资者可以购买最多4次股票，可行方案中的一种是： 日期 2, 5, 6, 10 价格 69, 68 , 64, 62 数据范围与约定$N\\le 5000, ans\\le 2^31$ 题解​ 题目分为两问:1.求出最长下降子序列的长度.2.求出有多少个不同的最长下降子序列.第一问是好做的,只要平凡的$n^2$或者$nlog_2n$的做法就可以求出.关键是第二问. ​ 既然要求有多少不同的最长下降子序列,我们就先来想想什么样的是不同的序列.首先肯定满足对于$i\\in [1,n],\\exists LIS1[i]\\neq LIS2[i]$,即存在一个位置使得两个子序列中这个位置的数不相同.那么我们需要做的就是计数并且去重.但是怎么更直接的判定重复呢?我们需要知道什么样的序列是一样(被重复计算)的.我们设$f[i]$表示以$a[i]$结尾的最长下降子序列的长度.然后我们发现,如果对于两个不同的数$i,j$,有$a[i]=a[j]$而且$f[i]=f[j]$,那么以$a[i],a[j]$结尾的这两个最长下降子序列一定是一样的.因为假设这两个序列中有一个数不相同,那一定会产生大小之分,然后作为”最长”下降子序列,这两个数一定都在这两个序列中,否则不是最长的.而这又和序列中的两个数不相同矛盾,所以假设不成立. ​ 现在我们知道了判断重复的条件,可以去重了.设$g[i]$表示以$a[i]$结尾的最长下降子序列有多少个,那么当我们发现$a[i]=[j]$且$f[i]=f[j]\\ \\ (j&lt;i)$的时候我们就可让$g[j]$归零.因为$i&gt;j,a[i]=a[j]$,所以能转移到$f[j]$的状态一定能转移到$f[i]$,也就是$g[j]$将被重复计算,我们将其去掉.类似的,当我们发现$f[i]=f[j]+1,a[i]&lt;aj$时,代表从$f[j]$可以转移到$f[i]$,这时我们让$g[i]+=g[j]$即可. 代码: int n, a[N], f[N], g[N], na[N], cnt, ans; int main() { read(n); memset(na, 128, sizeof(na));//采用nlogn求最长下降子序列长度,储存当前序列 for (int i = 1; i &lt;= n; ++i) { read(a[i]); int l = 1, r = n, pos = 0; while (l &lt;= r) {//二分查找第一个&gt;a[i]的数 int mid = l + r &gt;&gt; 1; if (na[mid] &gt; a[i]) pos = mid, l = mid + 1; else r = mid - 1; } na[pos + 1] = a[i]; ans = max(f[i] = pos + 1, ans); if (f[i] == 1) g[i] = 1;//显然 for (int j = 1; j &lt; i; ++j)//去重和转移过程 if (f[i] == f[j] &amp;&amp; a[i] == a[j]) g[j] = 0; else if (f[i] == f[j] + 1 &amp;&amp; a[i] &lt; a[j]) g[i] += g[j]; } int sum = 0; for (int i = 1; i &lt;= n; ++i)//统计数量 sum += (f[i] == ans) * g[i]; cout &lt;&lt; ans &lt;&lt; &quot; &quot; &lt;&lt; sum &lt;&lt; endl; return 0; }","categories":[{"name":"题目回顾","slug":"题目回顾","permalink":"http://yoursite.com/categories/题目回顾/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}],"author":"i-cookie"},{"title":"娱乐小文段","slug":"2019-10-31-娱乐小文段","date":"2019-10-30T16:00:00.000Z","updated":"2019-10-31T11:30:14.000Z","comments":true,"path":"2019/10/31/2019-10-31-娱乐小文段/","link":"","permalink":"http://yoursite.com/2019/10/31/2019-10-31-娱乐小文段/","excerpt":"","text":"​ 我一到机房，所有写题的人便都看着我笑，有的叫道，“AZC，你A+B又RE了！”我不回答，对老师说，“纯属失误，下次肯定没问题。”便写下”int mian()”。dalao们又故意的高声嚷道，“你一定又py了人家的代码了！”我睁大眼睛说，“你怎么这样凭空污人清白……”“什么清白？我前天亲眼见你棕了,抄袭了CZH的代码，吊着打。”我便涨红了脸，额上的青筋条条绽出，争辩道，“py不能算抄……抄袭！……OIer的事，能算抄么？”接连便是难懂的话，什么“超级玛丽”，什么“开心的金明”之类，引得众人都哄笑起来：机房内外充满了快活的空气。 ​ CSP之后，秋风是一天凉比一天，看看将近初冬；CZH整天的开着空调，也须穿上棉袄了。一天的下半天，没有一个同学，CZH正要开始切题。忽然间听得一个声音，“开心的金明…”这声音虽然极低，却很耳熟。看时又全没有人。站起来向外一望，那AZC便在门外对了门槛坐着。他脸上黑而且瘦，已经不成样子；拿一张成绩单，盘着两腿，下面垫一张广告纸，用胶棒在屁股上粘住；见了CZH，又说道，“超级玛丽…”SWK也伸出头去，一面说，“AZC么？你A+B的TLE还没修好呢！”AZC很颓唐的仰面答道，“这……下回再写罢。这一回是买铅笔，争取能做出来。”SWK仍然同平常一样，笑着对他说，“AZC，你又PY代码了！”但我这回却不十分分辩，单说了一句“不要取笑！”“取笑？要是不PY，怎么会封IP？”AZC低声说道，“网断…网…网”我的眼色，很像恳求SWK，不要再提。此时已经聚集了几个人，便和SWK都笑了。CZH开了题，1s切掉，摆在我面前。我在IDE里写下”int mina()”，放在CZH面前，见我满手是汗，原来我连主函数都不会写。不一会，我RE了，便又在旁人的说笑声中，跪着用这手慢慢爪巴去了。 “我的代码，你抄了么？”他问。“抄了一点。”“让我康康！”我交出所抄的代码去，他收下了，第二三天便还我，并且说，此后每一星期要举报我一回。我拿下来打开看时，很吃了一惊，同时也感到一种不安和悲痛。原来他的代码已经从头到末，都用define添改过了，不但会WA，连文法的错误，也到处都是。这样一直继续到PY完了他所切掉的题目：紫荆花之恋、琪露诺的冰雪小屋、AT678。 ​ AZC是鶸，所以AZC的代码当然是PY的，分数在0分以上，便不是自己的能力了：也无怪他们疑惑。但我接着便有作为蒟蒻被屠杀的命运了。第二年再做A+B，dalao的做法是全用splay来切的，随手已A完而还没有到下课的时候，便切几道题目，自然都是NOI+/CTSC。但偏有AZC夹在里边：给SWK捏肩，给CZH捶腿，要被屠杀了，围着看的也是一群dalao；被万人排斥的只有一个我。 ​ 神仙，A+B的TLE，我调出来了！”CZH似乎遇着了一个霹雳，突然笑起来；赶紧凑过来，打开提交记录，是十个”MLE”的方框，略略一翻，”int mnai()”，”for(int j;;i++)”，……果然都在内。这又使CZH发生新的笑意了，别人不屑于做，或懒得做的事，AZC却能够做成这个样。AZC确是一个蒟蒻。机惨他的仇恨，从此因怜悯完全消灭了。 $\\qquad \\qquad \\qquad =\\overline{\\underline{|May\\ Be\\ Continued|}}\\Rightarrow$","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[],"author":"i-cookie"},{"title":"P1280 尼克的任务","slug":"2019-10-28-P1280-尼克的任务","date":"2019-10-27T16:00:00.000Z","updated":"2019-10-28T13:21:34.000Z","comments":true,"path":"2019/10/28/2019-10-28-P1280-尼克的任务/","link":"","permalink":"http://yoursite.com/2019/10/28/2019-10-28-P1280-尼克的任务/","excerpt":"","text":"蒟蒻在DP之路上求索着 题目:传送门题目描述​ 尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。 ​ 尼克的一个工作日为$N$分钟，从第一分钟开始到第$N$分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第$P$分钟开始，持续时间为$T$分钟，则该任务将在第$P+T-1$分钟结束。 ​ 写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。 数据规模与约定对于所有的数据,$1\\le N\\le 10000,1\\le K\\le 10000$,保证每个任务起止时间都在$N$以内. 题解​ 这道题看起来像是线段覆盖类问题,但是发现可以对一些贪心策略举出反例来.所以你以为是贪心?其实是DP哒(雾).我们首先考虑怎么设计状态.我们发现总时间的范围并不大,所以我们尝试设$f[i]$表示时间$1…i$能获得的最大摸鱼时间.然后在每一个时间点分类讨论或者选取一个最优任务….我们发现一个问题.那就是题目中,尼克在闲着的时候如果有任务开始,他必须接一个,不能选择继续闲着.所以当前的选择可能会影响后面有哪些选择可以选,即后效性,不能这样推. ​ 但是题目并没有对任务结束时尼克的状态进行什么限制.如果我们倒着推,是不是就能实行类似于上述正着推的策略呢?于是我们尝试设$f[i]$表示$i…n$尼克能获得的最大摸鱼时间.那么尼克在这个时间点可能有两种状态: 现在闲着:$f[i]=f[i+1]+1$.即继承之前推出的时间然后闲着的时间+1. 现在刚接到一个任务:$f[i]=max(f[i],f[i+T(j)]),P[j]=i$. ​ 你可能会问,为什么在任务中不算一个状态?因为我们求的是$i…n$的最优解,不看前面的.由于$i$是起始点,所以目前讨论 的范围内不可能有任务开始在之前.所以只能是刚接到一个任务.注意到我们需要维护满足$P[j]=i$的所有任务.这怎么做呢?我们可以对每一个时间点维护一个$vector$,如果一个任务的起始时间是$i$,我们就把它的持续时间推进时间点$i$的$vector$中.然后扫描就可以了. ​ 代码: int n, k, f[10005]; vector&lt;int&gt; eds[10005]; int main() { read(n), read(k); for (int i = 1, x, y; i &lt;= k; ++i) read(x), read(y), eds[x].push_back(y); for (int i = n; i &gt;= 1; --i) { if (eds[i].empty()) f[i] = f[i + 1] + 1; else for (int j = 0; j &lt; eds[i].size(); ++j) f[i] = max(f[i], f[i + eds[i][j]]); } cout &lt;&lt; f[1] &lt;&lt; endl; return 0; } (其实这道题正着推其实也有办法?[擦汗])","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}],"author":"i-cookie"},{"title":"网络流学习笔记(upd 19-10-27)","slug":"2019-10-24-网络流学习笔记(upd-19-10-24)","date":"2019-10-23T16:00:00.000Z","updated":"2019-10-27T08:39:32.000Z","comments":true,"path":"2019/10/24/2019-10-24-网络流学习笔记(upd-19-10-24)/","link":"","permalink":"http://yoursite.com/2019/10/24/2019-10-24-网络流学习笔记(upd-19-10-24)/","excerpt":"","text":"曾经令我望而却步的知识,现在我要拿下它! 网络流的定义​ 所谓网络或容量网络指的是一个连通的赋权有向图$D=(V,E,C)$, 其中$V$是该图的顶点集，$E$是有向边(即弧)集，$C$是弧上的容量。此外顶点集中包括一个起点和一个终点。网络上的流就是由起点流向终点的可行流，这是定义在网络上的非负函数，它一方面受到容量的限制，另一方面除去起点和终点以外，在所有中途点要求保持流入量和流出量是平衡的。 (来自百度百科) ​ “网络流”本身就是一个非常形象的名字.我们可以类比输水管网络或者河网.对于一张有向图,有一个起点$S$和终点$T$,我们可以类比成水源和入海口.在这个基本模型上我们又定义了一些概念: 源点:起点$S$, 即水只流出的点. 汇点:终点$T$,即水只汇入的点. 流量:一条河道(边)上流过的流量 容量:一条河道(边)能容纳的最大流量 残量:一条河道(边)剩余未使用的容量,即容量-流量. 其中,一条边$(u,v)$的流量常表示为$f(u,v)$,容量表示为$c(u,v)$ 网络流的基本性质 对于任意一条边,都有$f(u,v)\\le c(u,v)$.其正确性显然,要不然河道就会溢出(或者水管爆裂) 对于一条边$(u,v)$的反向边$(v,u)$,有$f(u,v)=-f(v,u)$. $\\forall x\\neq S,x\\neq T,\\sum_{(u,x)\\in E}f(u,x)=\\sum_{(x,v)\\in E}f(x,v)$.这句话意思是除了$S,T$以外,其他点的流入量和流出量总是相等的,不能储存水. 最大流​ 最大流说的是整个网络的流量最大值.整个网络的流量就是$\\sum_{(S,v)\\in E}f(S,v)$,即从源点流出的流量之和.而一般可能河道的流量并不是被充分使用的,可能会有许多残量.最大流指的是尽量利用可利用的残量,能达到的最大流量. ​ 我们应该如何求解最大流呢?考虑一下,如果我们有一条从$S$到$T$的路径,上面所有边都没有被充分利用,那么我们是不是可以往这条路径中加水,从而在一定限度内增大流量呢?这条路径叫做增广路.形式化地,如果一条从$S$到$T$的路径$P$满足$\\forall (u,v)\\in P,f(u,v)&lt;c(u,v)$,则称路径$P$是一条增广路.我们可以向这条路径中加入多少水呢?显然是加到其中一条边满了为止,之后再加流量也不会增大了.换句话说,我们流量增加的量就是增广路上的最小残量. ​ 接下来我们来讲解一下增广路的求法. 增广路算法(Dinic Only)Dinic算法可以用来求二分图的最大匹配数,也可以用来求增广路.其基本思想如下: 在残量网络上进行$BFS$来给节点分层 在分层图上进行$DFS$寻找增广路,找到后回溯时更新这条边的剩余流量. ​ 其中,”残量网络”指的是由原图的所有节点和残量大于0的所有”未满”的边组成的图.我们假设$d[x]$表示从源点到$x$所经过的边数.然后按$d$对节点进行分层,这样我们最终一定会得到一张无环的图,即一个$DAG$.然后我们不断寻找增广路并向这条路中增大流量使得它不再是增广路.最终没有能够增广这个网络的路径的时候,这个网络流的流量就达到了最大值. ​ 但是,我们DFS是按照扫描出边的顺序来进行的,可能我们当前选择了$(u,v)$,但其实选择$(u,x)$来增广更优.因此我们要维护一个”反悔”操作.我们可以通过在反向边上加流量来达到.比如我们一开始选择了$(u,v)$,但是应该选择$(u,x),(y,v)$,这就相当于$(u\\rightarrow v),(y\\rightarrow v\\rightarrow u\\rightarrow x)$,让$(y,x)$路过的$(v,u)$和之前的劣解$(u,v)$相抵消,并一起流向了$x$,同时又有$(y,v)$,因此相当于反悔并选择了更优解. ​ 操作上,为了方便地维护相反边,我们可以使用”成对储存”的方法,把边的编号从2开始,即2,3互为反向边,4,5互为反向边.这样如果有一条边$x$,那么它的反向边就是$x\\ xor\\ 1$. ​ 我们已经说了$Dinic$算法的流程,接下来配合注释看一下代码实现. #include &lt;bits/stdc++.h&gt; #define inf 1145141919 #define N 50005 #define M 300005 using namespace std; int n, m, S, T, noe, maxflow; int to[M], len[M], nxt[M], head[N], dep[N], cur[N]; queue&lt;int&gt; q;//d指的是depth,即对图的分层,cur数组用来进行当前弧优化,下面会说到 inline void addedge(int from, int t, int l) { len[++noe] = l, nxt[noe] = head[from], head[from] = noe, to[noe] = t; len[++noe] = 0, nxt[noe] = head[t], head[t] = noe, to[noe] = from; return;//这里的len指的是残量,一开始没有反向边,所以是0,而正向边没有流量流过,所以是满的. } inline bool bfs() { memset(dep, 0, sizeof(dep));//多次bfs要清空 memcpy(cur, head, sizeof(cur));//cur数组指的是现在增广到哪一条边了, while (!q.empty()) q.pop();//记录cur的目的是忽略掉那些已经满了的没用的边. q.push(S), dep[S] = 1;//初始化 while (!q.empty()) { int temp = q.front(); q.pop(); for (int i = head[temp]; i; i = nxt[i]) if (len[i] &amp;&amp; !dep[to[i]]) { q.push(to[i]); dep[to[i]] = dep[temp] + 1;//分层 if (to[i] == T) return true; } } return false; } int dinic(int now, int flow) {//源点能为当前点提供的最大流量. if (now == T || !flow) return flow;//到了终点就回溯 int ret = 0;//ret统计了从这个点出发的所有边得到的增广量 for (int i = cur[now]; i; i = nxt[i]) {//只扫需要扫的边 cur[now] = i; if (dep[to[i]] == dep[now] + 1 &amp;&amp; len[i]) {//是图的下一层而且还有可以利用的容量 int temp = dinic(to[i], min(flow - ret, len[i]));//递归下去,返回途中的最小流量 len[i] -= temp, len[i ^ 1] += temp;//回溯时的增广操作 ret += temp;//每个点可能有多条出边,流量变化是总和 } if (ret == flow) return ret;//源点只能提供这些流量,再增广也没有意义了 } if (!ret) dep[now] = -1;//如果扫完全部都没有得到任何增广量,这个点就没用了 return ret; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); scanf(&quot;%d%d&quot;, &amp;S, &amp;T);//读入源点和汇点 noe = 1;//成对储存的技巧 for (int i = 1, x, y, z; i &lt;= m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); addedge(x, y, z);//从x到y有一条流量为z的边 } int flow = 0;//每次的增广量 while (bfs())//如果还有可以增广的从S到T的路径 while (flow = dinic(S, inf)) maxflow += flow;//统计增广量 cout &lt;&lt; maxflow &lt;&lt; endl;//输出最终结果 return 0; } 最小割网络流的割​ 割：设$C$为网络$G$中一些弧的集合，若从$G$中删去$C$中的所有弧能使得从源点$S$到汇点$T$的路集为空集时，称$C$为$S$和$T$间的一个割。通俗理解，一个图或网络的割，表示一个切面或切线，将图或网络分为分别包含源点和汇点的两个子集，该切线或切面与网络相交的边的集合，称为图像的割。 (百度百科) ​ 其实我们也可以类比无向图的割边.不同的是,如果割边是一条边,而割是边的集合,删去割边无向图将不会连通,而删去割中所有的边网络也会分成分别包含源点和汇点的两个没有边相连的部分.如果沿用河道的类比,那么一个割就是一些河道的集合,满足如果在这些河道中都建立水坝,将会没有水能够流向汇点. 最大流最小割定理这个定理的内容非常简洁明了:在任何网络中,最大流量=最小割容量 ​ 事实上可以感性理解这个定理.我们知道,网络的流量是从源点流出的流量之和,那么如果我们能找到一个割,就可以把这张图分成两个不相连的部分,一部分包含源点,一部分包含汇点.这样我们可以把这个网络想象成水管网络,节点是水管的交点,我们会发现所有的流量都从断点流出去了,无论流量有多大.所以我们发现任何一个流都一定$\\le$ 任何一个割的容量. ​ 然后我们来考虑最大流和最小割之间的关系:流的上限(最大流)显然是受到了网络中容量最小的若干边的限制,而最小割显然是包括那些边的.换言之,正是因为一些比较窄的河道限制了所有从$S$到$T$的路径上的流量,所以最大流就只能达到这些窄河道的容量和.同时,由于把这些河道去除则会使得所有从$S$到$T$的路径都缺一块(即断掉),且这些河道是相对最窄的,所以它们构成了最小割,最小割的容量是这些窄河道的容量和.因此我们得到:最大流=最小割 例题:小M的作物​ 这个题乍一看像是$DP$,但是实际上并不是.这道题体现了网络流的难点:建图.只要知道了图,求什么都好说,关键是以什么为流量,在谁与谁之间连边.我们首先考虑没有组合的情况,这种情况比较好连边,也就是以$0$点为$A$田地,$n+1$点为$B$田地,在田地与作物之间连接以收益为流量的边.然后我们考虑到,一个作物只能种在一块田地里啊,那就意味着在一种作物与两个田地的连边中,我们必须要切断一条.最终使得$A$田地和$B$田地没有同时相连的作物,换句话说,形成两个独立的部分.这不就是最小割模型吗?其实这种模型还有一个名字:两者取一式问题. ​ 然后问题来了,还有组合呢,这怎么办呢?我们知道,组合其实就是一组作物.这组作物共同拥有一个额外利益$c$.但是一条边显然不能同时指向两个点,所以我们建立一个虚点$x$同时代表组合内部的作物.可以结合下图理解.组$x$中含有$1$和$2$.作为”替身”,我们应该要求从$x$出发也能够走到$1,2$的出边,而且中途不能经过其他原有的边.因此我们从$x$向$1,2$连边,就可以直接走到$1,2$然后走它们的出边了.但是这条新边代表的是$x$和$1,2$的关系,而不是流量,所以为了不让它影响最终结果,我们把它设为“割不断”的边,也就是容量为$inf$. ​ 同时从题意来考虑,如果$1$被分给了$B$田地,那么就代表着从$A$田地出发是不能到达$1$的.然而从$A$田地到$1$有且只有两条道路:$0\\rightarrow 1$和$0\\rightarrow x\\rightarrow 1$.这两条路径上各自只有一条可以割断的边$0\\rightarrow 1$和$0\\rightarrow x$.所以只要组合内的作物被分到$B$,连接$A$和组合点的边一定会被切断(即无法获得在$A$的额外利益),符合题意.像下面这样建图然后仍然求最小割就好了. 费用流​ 对于一个网络,有时每条边$(u,v)$除了有容量的限制,还有费用的限制.这个费用通常以单位流量需要的费用$w(u,v)$的形式给出.也就是说当这条边的流量为$f(u,v)$的时候,这条边的总费用是$f(u,v)\\times w(u,v)$,由此产生出一系列费用流问题. 最小费用最大流​ 一个网络中花费最小的最大流称为”最小费用最大流”.显然,是在保证流量最大的基础上求最小费用.对于这种问题,我们将原先最大流中的”$BFS$寻找最大流”改为”$SPFA$寻找最小费用最大流”就可以了.要注意的是,记得我们当时建立反向边来通过抵消原先决策来实现反悔操作.同样,为了抵消原先操作,我们所建立的反向边的费用应该是负的.因为每次寻找的都是单位费用最小的增广路,所以最终的费用和也是最小的 ​ 流程上是这样的: 1. 用SPFA寻找满足以下条件的路径 - 可以增广 - 在增广路中总的单位费用最小 2. 用dinic对这条路增广.具体内容结合代码理解. inline bool spfa() {//BFS改SPFA memset(dis, 0x3f, sizeof(dis));//dis[i]指的是从S到i的最小费用 memcpy(cur, head, sizeof(cur)); memset(vis, 0, sizeof(vis)); while (q.size()) q.pop(); q.push(S), dis[S] = 0; while (!q.empty()) { int temp = q.front(); q.pop(); vis[temp] = 0; for (int i = head[temp]; i; i = nxt[i]) if (len[i] &amp;&amp; dis[to[i]] &gt; dis[temp] + cst[i]) {//松弛操作,前提是还有剩余流量 dis[to[i]] = dis[temp] + cst[i]; if (!vis[to[i]]) { vis[to[i]] = 1; q.push(to[i]); } } } return (dis[T] != dis[0]);//如果dis[T]是inf,就代表没有增广路 } int dinic(int now, int flow) { if (now == T || !flow) return flow; int ret = 0; vis[now] = 1; for (int i = cur[now]; i; i = nxt[i]) { if (len[i] &amp;&amp; !vis[to[i]] &amp;&amp; dis[to[i]] == dis[now] + cst[i]) { //有剩余流量,没有被访问,而且是增广路上的点 int temp = dinic(to[i], min(flow - ret, len[i])); len[i] -= temp, len[i ^ 1] += temp;//增广 ret += temp, mincost += temp * cst[i];//记录最小费用 } if (ret == flow) return ret; } if (!ret) dis[now] = -1;//删掉没有贡献的点 return ret; } 感谢@_violet和@suwakow提供的帮助和参考","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://yoursite.com/categories/经验总结/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"}],"author":"i-cookie"},{"title":"trie字典树","slug":"2019-10-23-trie字典树","date":"2019-10-22T16:00:00.000Z","updated":"2019-10-23T07:54:58.000Z","comments":true,"path":"2019/10/23/2019-10-23-trie字典树/","link":"","permalink":"http://yoursite.com/2019/10/23/2019-10-23-trie字典树/","excerpt":"","text":"字典树的定义 又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。 (百度百科) 字典树的性质 根节点不包含字符，除根节点外每一个节点都只包含一个字符 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串 每个节点的所有子节点包含的字符都不相同 字典树的用途 字符串排序 按照字典序排序字符串.只需要构建一棵字典树,并且令它的儿子们按照字母的字典序从左到右排列,然后对字典树先序遍历即可 最长公共前缀问题 用所有字符串建立字典树,然后两个串的最长公共前缀只需要找到它们的公共祖先,然后计算深度就可以了. 字符串的查找 用给定的串建立字典树,然后用需要匹配的串在字典树上查找. 字典树的建立我们设$trie[i][j]$表示第i个节点的第j个儿子的节点编号.采用动态开点.下面的伪代码表示插入一个字符串的过程 inline void insrt(char a[]) { l = length(a), 当前节点 = 0; for i = 0 to l if 当前节点没有第a[i]个位置的儿子 then 新建节点; 当前节点 = 新节点;//模拟递归 else 当前节点 = 第a[i]个位置的儿子; return; } 例题:于是他错误的点名开始了这道题差不多是$trie$字典树的模板题.首先我们可以用题目给出的所有名字建立一个$trie$,然后对于教练报的每一个名字,我们都可以在字典树上一个一个字符地匹配到.对应题目中的三种输出,我们寻找的结果有三种情况: 成功找到了单词的最后一位,返回OK 成功找到了单词的最后一位,但是已经找到过至少一次了,返回REPEAT 没有找到单词的最后一位,返回WRONG 那么我们怎么知道找没找到过呢?由字典树的性质我们可以知道,表示一个单词的树链是唯一确定的,所以我们只需要在链尾节点记录一个被找到的次数,就可以确定返回什么了.代码: #include &lt;bits/stdc++.h&gt; using namespace std; int n, m; char name[10005][51], ask[55]; struct node { int to[500005][26], size = 0, times[500005]; inline void insrt(char a[]) {//插入一个字符串 int l = strlen(a), now = 0, i;//now表示当前节点 for (i = 0; i &lt; l; ++i) {//循环模拟递归 if (!to[now][a[i] - 96]) {//如果没有这个儿子 to[now][a[i] - 96] = ++size; now = size; } else//有这个二儿子 now = to[now][a[i] - 96]; } return; } inline int query(char a[]) {//查询字符串被找到了几次 int l = strlen(a), now = 0, i; for (i = 0; i &lt; l; ++i) { if (!to[now][a[i] - 96])//这个单词不在字典树中 return 0; else now = to[now][a[i] - 96];//这个单词在字典树中 } times[now]++; return times[now] &gt; 1 ? 2 : 1; } }trie; int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%s&quot;, name[i]); trie.insrt(name[i]); } cin &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) { scanf(&quot;%s&quot;, ask); int ans = trie.query(ask); if (!ans) printf(&quot;WRONG\\n&quot;); if (ans == 1) printf(&quot;OK\\n&quot;); if (ans == 2) printf(&quot;REPEAT\\n&quot;); } return 0; } 字典树的其他应用给出一个数列$a_1…a_n$,询问这个数列中的最大异或数对,即求$max_{i,j\\in [1,n]}(a_i\\ xor\\ a_j)(i\\neq j)$. 这里有很多数,所以我们显然不能直接对数开$trie$.而题目要求我们异或,所以一个自然的想法就是用每个数的二进制建树,这样就可以使得$trie$只有二叉并且深度不会太大,最大$log_2a_i$.接下来我们怎么异或呢?显然的,字典树上的寻找是需要一个基准的.我们对于每一个$a_i$,在字典树上寻找另一个数进行异或.而由异或的定义我们知道,我们寻找的数的每一位是尽量和$a_i$不同的,而且要优先考虑高位.因此我们在字典树上可以直接由高位到低位贪心,在字典树上有这一叉的前提下,如果$a_i$这一位是1,我们就寻找0,否则寻找1,这样最后找到的数和$a_i$异或起来就可以保证最大了.由于代码简单这里就不再出示.","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://yoursite.com/categories/经验总结/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"字典树","slug":"字典树","permalink":"http://yoursite.com/tags/字典树/"}],"author":"i-cookie"},{"title":"线性基","slug":"2019-10-12-线性基","date":"2019-10-21T16:00:00.000Z","updated":"2019-10-23T08:13:18.000Z","comments":true,"path":"2019/10/22/2019-10-12-线性基/","link":"","permalink":"http://yoursite.com/2019/10/22/2019-10-12-线性基/","excerpt":"","text":"今天做题的时候听说了一个新的知识点,叫做线性基.于是来学一下,水写个博客. 重要参考: Menci dalao的Blog 线性基的定义张成设$T\\subseteq S$，所有这样的子集T的异或和组成的集合称为集合S的张成，记作 $span(S)$。即，在$S$中选出任意多个数，其异或和的所有可能的结果组成的集合。 线性相关若集合$S$中存在一个元素$S_i$，使得$S$在去除这个元素后得到的集合$S’$的张成$span(S’)$中包含$S_i$，则称集合$S$线性相关。 相对的，如果不存在这样的元素$S_i$，则称集合$S$线性无关。 线性基我们称集合$B$是集合$S$的线性基，当且仅当： $S\\subseteq span(B)$，即$S$是$B$的张成的子集； $B$是线性无关的。 集合$B$中元素的个数，称为线性基的长度。 (以上内容来自$Menci\\ dalao$的博客,更多详细定义及内容请参考Menci dalao的Blog) 线性基的性质我们由原集合构造出了原集合的线性基,这个集合中的数字满足以下性质: 从线性基中选择一些数异或起来,能够得到原集合中的任何一个数.换句话说,原集合中的任何一个数都可以用线性基中若干个数异或起来得到. 线性基是能够满足上一条性质的最小集合 线性基中的数无法得到0 线性基中所有满足$j&lt;i$的$s[j]$的第$i$位以及更高位不可能是1,这一点由构造方法保证 整个线性基数组中只有$s[i]$的第$i$位是1. 形式化地,线性基s中的数满足$s_x\\ xor\\ s_y\\ xor…xor\\ s_z=a(x,y,z\\in [1,sizeof(s)],a,s_x,s_y,s_z\\in S)$. 线性基的主要作用线性基可以用来解决一类特殊问题:在一列数中任选若干个,使得他们异或的结果最大.即求 $max{ a_i\\ xor\\ a_j\\ xor …\\ xor\\ a_k},\\ a_i,a_j…a_k\\in S,i\\neq j\\neq…\\neq k$. 这个问题我们采用线性基来解决.首先我们要明确线性基的构造方法. for i 由高到低枚举数字t的每一个二进制位 - 如果这一位是0,跳过,否则: - 如果s[i] == 0, t = t ^ s[i]; - 如果s[i] == 1 then for j 循环[0,i) 如果t的第j位是1,则t=t^s[k]; for j 循环(i,maxl] 如果s[j]的第i位是1,则s[j]=s[j]^t; s[i] = t; 算法结束. 最大子集异或和问题这是线性基能解决的最基本问题.我们考虑让和最大,也就是让高位尽量为1.而且我们根据性质可以发现我们构造的线性基满足性质4和5,所以只有异或$s[i]$,才可能使得第i位变成1,所以我们可以直接把所有线性基中的数异或起来得到结果. inline void insrt(int t) {//插入线性基 for (int i = 63; i &gt;= 0; --i) {//由高到低扫描 if (t &amp; (1ll &lt;&lt; i) == 0) continue; if (s[i]) t ^= s[i]; else { for (int j = 0; j &lt; i; ++j) if (t &amp; (1ll &lt;&lt; j)) t ^= s[j]; for (int j = i + 1; j &lt;= 63; ++j) if (s[j] &amp; (1ll &lt;&lt; i)) s[j] ^= t; s[i] = t; return; } } return; } inline long long query(int t) {//最大异或和 long long res = 0; for (int i = 0; i &lt;= MAXL; i++) res ^= a[i]; return res; } 这样问题就解决了.","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://yoursite.com/categories/经验总结/"}],"tags":[{"name":"TAG","slug":"TAG","permalink":"http://yoursite.com/tags/TAG/"}],"author":"i-cookie"},{"title":"STL_map,set,string自制小辞典","slug":"STLSTL","date":"2019-10-16T16:00:00.000Z","updated":"2021-09-12T09:01:57.907Z","comments":true,"path":"2019/10/17/STLSTL/","link":"","permalink":"http://yoursite.com/2019/10/17/STLSTL/","excerpt":"","text":"众所周知,C++ = C + STLmap功能:灵活的开桶容器,能够让各种类型的变量作为数组下标,空间要求较低,可以不离散化而开桶之类的 原理:Map是基于树（红黑树）的实现方式，即添加到一个有序列表，在$\\Theta(log\\ n)$的复杂度内通过key值找到value,但是常数大. 头文件及定义#include &lt;map&gt; ... map&lt;Typename1, Typename2&gt; mp; 其中$Typename1$是第一关键字,$Typename2$是第二关键字,使用时相当于$mp[Typename1] = Typename2$ 成员函数/*定义*/ map&lt;string, string&gt; mp; /*插入元素*/ mp.insert(pair&lt;string, string&gt;(&quot;Monday&quot;, &quot;星期一&quot;)); mp.insert(pair&lt;string, string&gt;(&quot;Tuesday&quot;, &quot;星期二&quot;)); /*删除元素*/ map&lt;string, string&gt;::iterator point; point = mp.find(&quot;Tuesday&quot;);//使用迭代器删除 mp.erase(point); mp.clear();mp.erase(mp.begin(), mp.end());//全部删除 /*查找并输出元素*/ point=mp.find(&quot;Monday&quot;); if (point != mp.end()) cout &lt;&lt; point-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; point-&gt;second; /*其他操作*/ mp.count(&quot;Tuesday&quot;);//返回指定元素的出现次数 mp.empty();//判断是否为空 mp.size();//返回元素个数 set功能能够在插入元素时自动排序,同时set中没有重复的元素,能够进行高效查找. 原理set同map一样是基于红黑树的,插入时间复杂度为$\\Theta(log\\ n)$,但是常数较大 头文件及定义#include &lt;set&gt; ... set&lt;Typename&gt; s; 成员函数#include &lt;set&gt; ... set&lt;int&gt; s; /*插入元素*/ s.insert(514); s.insert(1919); s.insert(114);//这些数字插入后会自动排序 /*删除元素*/ s.erase(iterator);//删除迭代器指向的值 s.erase(l, r);//删除迭代器指定区间内部的值 s.erase(key);//删除键值为key的元素的值 /*查找元素*/ pair&lt;set&lt;int&gt;::const_iterator, set&lt;int&gt;::const_iterator&gt; point; point = s.equal_range(514);//返回第一个&gt;=给定值的元素位置和第一个&gt;的元素位置. cout &lt;&lt; *point.first &lt;&lt; &quot; &quot; &lt;&lt; *point.second; s.find(114);//返回给定值的迭代器,否则返回s.end() s.lower_bound(514);//返回第一个大于等于给定值的迭代器 s.upper_bound(514);//返回最后一个大于等于给定值的迭代器 /*其他操作*/ s.begin();s.end();//返回首尾迭代器 s.empty();s.size();//判断是否为空和记录大小 s.clear();//清空set s.count(1919);//返回出现次数(其实只有0或者1) set&lt;int, cmp&gt; s;//支持比较函数 string功能string是功能强大的字符串容器,类似于C语言的char数组,但是又有所不同,可以支持大量的操作. 原理相当于储存着字符的vector容器,其部分操作虽然复杂度相当于暴力,但是非常方便 头文件与定义#include &lt;string&gt; ... string s = &quot;2333333&quot;;//直接赋值字符串 string t = s;//字符串间的赋值 string s(10, &#39;6&#39;);//长度为10,每一个字符都是&#39;6&#39; string t(s, 6);//把s的第6个字符到结尾拷贝到t中. string t = string(s, 6); string t(s, 0, 5);//把s从0开始的5个字符拷贝到t中 string s = string(str1, 0, 5); char c[11] = &quot;hello world&quot;; string s(c, 6);//把c数组的前6个字符拷贝到s中 string s = string(c, 6); string s = string(&quot;2333333&quot;, 5);//这里的&quot;2333333&quot;应该视为char数组,所以是拷贝前5个字符而不是第五个往后的字符 成员函数/*字符串信息*/ s.size();s.length();//返回字符串的长度 s.substr(x);//返回字符串的x到结尾 s.substr(x, 10);//返回字符串下标为x处开始的10个字符 s.reverse(l, r);//翻转字符串中两个指针规定区间的字符 s.begin();s.end();//返回开头位置或者结尾位置的后一个位置 /*查找*/ s.find(t);//查找t在s中第一次出现的位置 s.find(t, l);//查找t在s的[l, end()]中第一次出现的位置 s.find(ch, l, n);//查找字符数组ch的前n个字符在s的[l, end]中第一次出现的位置 s.find(c, l);//查找字符c在s的[l, end()]中第一次出现的位置 //rfind系列可以进行反向操作 /*删除内容*/ s.erase(l, n);//将s中从l开始的n个字符删掉 /*赋值*/ s.assign(n,ch);//n个字符ch赋值给字符串s s.assign(t);//将字符串t赋值给字符串s s.assign(t, l, n);//将字符串t从l开始的n个字符赋值给字符串s s.assaign(ch, n);//将字符数组ch的前n个字符赋值给字符串s /*替换*/ s.replace(p, n, m, ch);//删除p开始的n个字符，然后在p处插入m个字符ch s.replace(p, n, t);//删除从p开始的n个字符，然后在p处插入字符串t s.replace(p, n, t, l, m);//删除p开始的n个字符，然后在p处插入字符串t中从l开始的m个字符 s.replace(p, n, ch, m);//删除p开始的n个字符，然后在p处插入字符数组ch的前m个字符 /*添加*/ s.append(n, c);//在当前串结尾添加n个字符c s.append(t);//把字符串t接到当前串的结尾 s.append(t, l, n);//把字符串t中从l开始的n个字符连接到当前字符串的结尾 append(ch, n);//把字符数组ch的前n个字符连接到当前字符串结尾 /*插入*/ s.append(n, ch);//在当前字符串结尾添加n个字符c s.append(t);//把字符串t连接到当前字符串的结尾 s.append(t, l, n);//把字符串t中从l开始的n个字符连接到当前串的结尾 append(ch, n);//把字符数组ch的前n个字符连接到当前串的结尾","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"}],"author":"i-cookieShow that"},{"title":"二分图初步","slug":"二分图初步","date":"2019-10-15T16:00:00.000Z","updated":"2019-10-16T01:23:46.000Z","comments":true,"path":"2019/10/16/二分图初步/","link":"","permalink":"http://yoursite.com/2019/10/16/二分图初步/","excerpt":"","text":"联赛知识点不列不知道,一列觉得自己就像一个pupil一样,于是赶紧学点新东西二分图的定义:如果能把一张无向图(连不连通都可以)分成两个点集$V,V’; V\\cap V’=\\emptyset$,使得两个点集内部无边,则这张图是二分图,分成的两个点集分别称为左部和右部.二分图判定定理一张无向图是二分图$\\Leftrightarrow$这张无向图中没有奇环. 那么这个定理有什么用呢?显然是可以方便地判断一张图是不是二分图,然后利用二分图的性质了.由于二分图的两个点集内部没有边,所以从一个点到同一集合中的另一个点一定会经过偶数条边,其中一半是出集合的,一半是进集合的.而且这条路径上的点是$V,V’$中的点交替出现的.所以我们如果给这张图着色,并且要求任意一条边的两个端点颜色不能相同,那么我们最少只需要两种颜色. 这就有了二分图染色判定法.即从一个点开始,给它染上一种颜色,那么这张图上的所有点颜色都应该确定了.我们通过DFS或者BFS给点染色,如果有相连的点未染色,就染上不同的颜色.如果有相连的点颜色相同,就返回0. 例题 [NOIP2010]关押罪犯分析题目非常清楚地告诉了我们要把罪犯(点)分成两个部分,然后使得每个部分内部的边的最大值最小.那么我们可以获得两个信息:首先要把点分成两个不相交的集合,其次还要使得最大值最小.我们猜测这是二分图和二分答案结的题目. 但是题目貌似没有办法让每个集合内部没有边,那我们先来看能不能二分答案.答案是最大边的最小值,而这个根据不同的分法显然能构成一个单调的结果序列.所以我们二分是否存在一个分法,使得集合内部最大的边权$&lt;mid$,然后来缩小范围. 那么既然要求集合内部的边都小于$mid$,那么不小于$mid$的边就只好放在集合之间.但是连好所有$&gt;=mid$的边的话可能会导致图中存在奇环而出现两个点既应该在一个集合又不应该在一个集合的情况,所以我们要通过染色法来判断这张图是不是二分图.这样我们就得出了解法:二分$mid$,在染色时只看$&gt;=mid$的边,如果符合就代表能够分成两个点集,否则不能. 代码:#include &lt;bits/stdc++.h&gt; #define N 100005 using namespace std; inline void read(int &amp;x) { x = 0; char ch = getchar(), w = 0; while (!isdigit(ch)) w = (ch == &#39;-&#39;), ch = getchar(); while (isdigit(ch)) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); x = w ? -x : x; return; } int n, m, noe; int to[N &lt;&lt; 1], len[N &lt;&lt; 1], nxt[N &lt;&lt; 1], head[20005]; int col[20005]; inline void addedge(int from, int t, int l) { len[++noe] = l; nxt[noe] = head[from]; head[from] = noe; to[noe] = t; return; } inline bool paint(int st, int c, int mid) { queue&lt;int&gt; q;//广搜染色 q.push(st); col[st] = c; while (!q.empty()) { int temp = q.front(); q.pop(); for (int i = head[temp]; i; i = nxt[i]) { if (len[i] &lt; mid)//只看&gt;=mid的边 continue; if (col[to[i]] == col[temp]) return 0; if (!col[to[i]]) col[to[i]] = 3 - col[temp], q.push(to[i]); } } return 1; } inline bool check(int nowans) { memset(col, 0, sizeof(col)); for (int i = 1, flag = 1; i &lt;= n; ++i) { if (!col[i]) flag = paint(i, 1, nowans); if (!flag) return 0; }//二分答案的检验 return 1; } int main() { read(n), read(m); for (int i = 1; i &lt;= m; ++i) { int x, y, z; read(x), read(y), read(z); addedge(x, y, z); addedge(y, x, z); } int l = 0, r = 1145141919; while (l &lt; r) { int mid = l + r &gt;&gt; 1; // cout &lt;&lt; mid &lt;&lt; &quot; &quot; &lt;&lt; check(mid) &lt;&lt; endl; if (!check(mid)) l = mid + 1; else r = mid; }//因为&gt;=mid的都不能分,所以最终答案=mid-1 printf(&quot;%d\\n&quot;, (l == 0 ? 0 : l - 1));//别忘了0 return 0; } 二分图的最大匹配先来说一下二分图的匹配: 互相独立没有公共顶点的一组边称为图的一个匹配.对于一组匹配,我们称它所涉及到的点为匹配点,未涉及的叫非匹配点.同样的方法定义了匹配边和非匹配边.如果在二分图中存在一条连接两个非匹配点的路径,而且这条路径还是匹配边和非匹配边交错组成,那么这条路被称为这个匹配的增广路.为什么叫”增广”呢?因为我们由定义可以发现,由于是匹配与非匹配交错,但是开头结尾都是非匹配边,所以非匹配边一定比匹配边多一条.那么我们把路径上每个点以及每条边的性质取反,就会发现它仍然是一组匹配.所以这条路实现了对它对应匹配的”增广”.二分图的最大匹配就是含有边数最多的匹配.当然因此我们就可以推出以下结论: 二分图的一组匹配是最大匹配$\\Leftrightarrow$图中没有这个匹配的增广路(因为它无法再被增广了) 那么我们是不是可以通过逐步增广的方式来求出最大匹配呢?答案是肯定的.由此引出重点:匈牙利(增广路)算法 匈牙利算法这个算法主要用来计算二分图的最大匹配.下面用文字介绍一下它的过程(由于本人水平和时间问题,不再上图,无法理解文字者请自行百度图解,抱歉) 首先把所有边都当作非匹配边,即一切从零开始. 寻找增广路,即寻找匹配的右部节点.方法如下: 扫描当前点u的出边,访问对面所有满足以下条件之一的点v v是非匹配点,那么这条出边就是一条增广路. v虽然已经匹配了,但与它匹配的点x有能力让位并换一个点y配对,也就是取消一个匹配(x,v),并增加两个匹配(x,y)(u,v),这样也找到了增广路. 第二个条件回溯时取反则u也得以匹配.操作上就是由边(u,v)递归到y,由已有的匹配(v,x)递归到x,扫描x的出边找到y,表明可以让位并创建(x,y)返回时把路径取反就完成了上述表明的操作并得到了新的两个匹配(x,y)和(u,v). 重复第二步,直到没有增广路 以上就是匈牙利算法的过程. 例题【模板】二分图匹配本题已经明确了图是二分图,且左部和右部都是从1开始标号.由于数据范围小我们可以建立邻接矩阵来存图.因为我们只需为左部点向右部点寻找匹配,所以只由左部点向右部点连边.然后进行匈牙利算法.代码: int dfs(int now) { for (int i = 1; i &lt;= m; ++i) if (!vis[i] &amp;&amp; edge[now][i]) { vis[i] = 1; if (!conn_y[i] || dfs(conn_y[i])) { conn_x[now] = i;//满足两个条件之一即可 conn_y[i] = now; return 1; } } return 0; } inline void maxmatch() { int ans = 0; for (int i = 1; i &lt;= n; ++i) { memset(vis, 0, sizeof(vis)); ans += dfs(i); } cout &lt;&lt; ans &lt;&lt; endl; return; }","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://yoursite.com/categories/经验总结/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"二分图","slug":"二分图","permalink":"http://yoursite.com/tags/二分图/"}],"author":"i-cookie"},{"title":"10.14比赛","slug":"10.14ZR冲刺赛D1","date":"2019-10-14T08:10:00.000Z","updated":"2019-10-15T08:10:34.000Z","comments":true,"path":"2019/10/14/10.14ZR冲刺赛D1/","link":"","permalink":"http://yoursite.com/2019/10/14/10.14ZR冲刺赛D1/","excerpt":"","text":"T1:小 D 正在研究序列。 对于一个正整数序列而言，小 D 认为他是好的，当且仅当任意相邻两个数字均为一个奇数和一个偶数。 形式化地，对于一个序列 $b1, b2, · · · , bm$ 而言，小 D 认为他是好的，当且仅当对于任意 $1 \\le i &lt; m$，有 $b_i$ 为奇数且$b_{i+1}$ 为偶数，或 $b_i$ 为偶数且 $b_{i+1}$ 为奇数。 小 D 得到了一个长度为 n 的序列 $a1, a2, · · · , an$，小 D 想要通过重新排列它，使它变为一个好的序列。小 D 定义一种重新排列方案的代价为重排后每个数字位置差的绝对值之和。小D 想要最小化重排的代价。 此外，小 D 还想在最小化重排代价的基础上，最小化结果序列的字典序。但是小 D 并不会，请你帮帮他。 题解1实际上奇数和偶数是独立的,我们可以考虑其中一种,另一种自然就会了.那么我们比较容易得到,在不考虑字典序的情况下,我们只需把所有奇数顺序不变,放在各个奇数(偶数)位置上.那么如果考虑字典序怎么办呢?显然是需要对顺序做一些安排.我们假设有两个数在$X,Y$,要放到$A,B$,其中$X&lt; Y&lt; A&lt; B$.那么如果我们把X放在A位置,代价就是$A-X+B-Y$.如果把$X$放在$B$位置,代价就是$B-X+A-Y$.都是$A+B-X-Y$,所以换顺序代价.而方向不同的换顺序就会出现交叉,显然代价会变大.所以对于一段方向都向左的情况,我们从小到大排序,从左往右放.向右同理. T2:小 D 得到了许多灯泡。这些灯泡共有 n 个，小 D 把它们排成了一行，并依次编号为 $1, 2, · · · , n$。这些灯泡有许多不同的颜色，小 D 把颜色依次编号为 $1, 2, · · · , k$，则第 i 个灯泡的颜色为 $c_i$。 初始时，所有灯泡都是灭的。小 D 每次操作会把某一种颜色的灯泡全部翻转状态，即从亮变灭或从灭变亮。在每次操作完后，小 D 想要知道有多少极长的亮灯区间。 形式化地，我们称一个区间 $[l, r]$ 是极长的亮灯区间，当且仅当编号为 $l, l + 1, l + 2, · · · , r$ 的灯都是亮着的，而编号为 $l − 1$ 以及 $r + 1$ 的灯要么不存在，要么是灭着的。 但是小 D 并不会，请你帮帮他。 题解2本题用到了一种技巧:根号分治.我们可以把这道题抽象成一个图的问题.点对应序列中亮起的点,边只在相邻的亮着的灯连起来.这样的话由于无环,点数一定比边数多1.因此我们知道,联通块数等于亮着的灯数-相邻亮着的点之间的边数. 点数可以直接在输入的时候进行维护.而边数可以通过分块(分类来完成).我们可以把每一个颜色连续的部分压成一个点,向相邻颜色连边,建立另外一张图.我们假设有一个阈值B,根据灯泡出现次数$deg[u]$和B的关系分类.比如我们现在把一个点u点亮.如果它是一个大点,那么大点不超过n/B个,我们就暴力去搞.如果是一个小点就不好暴力,那么我们反过来想.当我们改变一个小点u的时候它周围的点v必须是on才对答案有贡献.也就是v被修改过.从u考虑不好考虑,所以我们修改v时找到周围的u,使其标记+1,代表下次修改u时答案会+1. T3:小 D 正在研究一场锦标赛。这场锦标赛共有 n 位选手参加，他们被依次编号为 $1, 2, · · · , n$。选手两两之间会进行一场比赛，在两名选手比赛时，编号较小的那个有 $p$ 的概率取胜，而较大的那个有 $1 − p$ 的概率取胜。换言之，对于选手 $i, j(i &lt; j)$之间的比赛，有 p 的概率是选手 i 获胜，而剩余的概率是选手 j 获胜。 最终，锦标赛主办方会给其中若干选手颁奖。为了显得公平公正，主办方需要保证这些人胜过了其余的所有人。形式化地，若主办方给集合 $S$ 中的选手颁奖，则主办方需要保证对于任意 $i ∈ S$ 和 $j \\notin S$在 i 和 j 的比赛中是 i 胜出。 小 D 想要知道，对于每个 $1 ≤ k &lt; n$，最终主办方可以给 k 个选手颁奖的概率是多少。具体的输出方式请见输出格式部分。 但是小 D 并不会，请你帮帮他。 输出格式 为了避免太大规模的输出，设 $v_k$ 表示最终可以给 k 个选手颁奖的概率，定义函数 $f(k)$ 满足 $f(1) = 1$，而 $f(i) = (f(i − 1))^2 + 2$，设 $V =\\sum_{k=1}^{n-1} v_k · f(k)$，则你只要求出 $V$ 的值即可。 为了避免浮点数精度误差，可以证明 $V$ 可以写成 $\\frac{x}{y}$ 的形式，则你只要输出 $x ·y^{-1} mod M$ 的值即可，其中 $M = 998244353(= 223 × 7 × 17 + 1$). 题解3对于某个K,只要存在一个大小为k的集合,那这个集合一定是唯一的.因为如果可以更换一个人的话,胜负关系会矛盾. 如果我们考虑$F(n,k)$表示$n$个人中有$k$个人得奖的概率.当我们推到$n+1$的时候,我们可以考虑两种情况:如果$n+1$在集合内,那就要赢过集合外的所有人,如果在集合外,那就要输给集合内的所有人.而其他人编号都比$n+1$小.所以我们有:$$F(n+1,k)=F(n,k)\\times p^k+F(n,k-1)\\times q^{n-k+1}\\ \\ (q=1-p)$$然而只有一个式子是求不出递推式的.我们还可以从1的角度考虑.如果1在集合内,那就赢过集合外所有人.如果1在集合外,就输给集合内所有人,而所有人编号都比1大.所以我们又可以得到:$$F(n+1,k)=F(n,k)\\times q^k+F(n,k-1)\\times p^{n-k+1}$$两个式子联立就可以消去$F(n+1,k)$,整理得到:$$F(n,k)\\times (p^k-q^k)=F(n,k-1)\\times (p^{n-k+1}-q{n-k+1})$$当然了初值为$F(n,0)=1$,所以在$p\\neq q$也就是$p\\neq \\frac{1}{2}$时我们可以$\\Theta(n)$算出答案.我们选择1,n这两个位置的原因是其他点的序号都比这个点大或者小,所以可以计算,否则不知道集合中的人是哪些,无法计算. 接下来就是$p=\\frac{1}{2}$的情况了.这时任何人胜率都是$\\frac{1}{2}$,所以我们选出k个人作为最后的胜者,则有$$F(n,k)=C^k_n\\times \\frac {1}{2^{k(n-k)}}$$时间复杂度都是$\\Theta(n)$或者$\\Theta(nlog_2n)$","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"根号分治","slug":"根号分治","permalink":"http://yoursite.com/tags/根号分治/"}],"author":"i-cookie"},{"title":"高精加减乘除(基础模板,不是很全)","slug":"高精度","date":"2019-10-12T16:00:00.000Z","updated":"2019-10-13T15:24:38.000Z","comments":true,"path":"2019/10/13/高精度/","link":"","permalink":"http://yoursite.com/2019/10/13/高精度/","excerpt":"","text":"在抄写借鉴了许多题解之后,由于害怕板子找不到了我决定水写一篇博客来总结一下高精的加减乘除.当然了其实只有加和乘除罢了.顺便一说,我还不会压位QWQ 高精度加法(高精+高精)其实就是暴力模拟列竖式,非常易懂 inline node super_plus(node a, node b) { node ans; memset(ans.c, 0, sizeof(ans.c)); int la = a.length, lb = b.length, lc = max(la, lb); for (int i = 1; i &lt;= lc; ++i) { ans.c[i] += a.c[i] + b.c[i]; ans.c[i + 1] += (ans.c[i] &gt;= 10);//处理进位 ans.c[i] -= 10 * (ans.c[i] &gt;= 10); } if (ans.c[lc + 1]) lc++;//每个高精度数用结构体保存 ans.length = lc;//结构体中记录长度和数值. return ans; } 高精度乘法(高精乘单精)inline node super_mul(node x, int y) { int lx = x.length, lr; node ret; lr = lx + 10;//保险起见 for (int i = 1; i &lt;= lx; ++i) ret.c[i] += x.c[i] * y;//由于我不会压位,所以不担心爆炸 for (int i = 1; i &lt;= lr; ++i) { ret.c[i + 1] += ret.c[i] / 10; ret.c[i] %= 10;//乘完了再进位 } while (ret.c[lr + 1]) lr++;//记录长度 while (!ret.c[lr]) lr--;//去除前导零(前面的都是为了保证确实是前导的0 ret.length = lr;//保存长度 return ret; } 高精度乘法(高精乘高精)inline node super_mul(node x, node y) { int lx = x.length, ly = y.length, lr = lx + ly - 1; //乘积最小位数是乘数位数相加-1 node ret; memset(ret.c, 0, sizeof(ret.c)); for (int i = 1; i &lt;= lx; ++i) for (int j = 1; j &lt;= ly; ++j) ret.c[i + j - 1] += x.c[i] * y.c[j]; for (int i = 1; i &lt;= lr; ++i) { ret.c[i + 1] += ret.c[i] / 10; ret.c[i] %= 10;//同样由于不压位可以先乘后进 } if (ret.c[lr + 1]) lr++;//最多增加一位 ret.length = lr; return ret; } 高精度除法(高精除单精)高精除高精考了我就认栽 inline node super_divid(node x, int y) { node ret; int lr = x.length; for (int i = lr; i; --i) {//暴力模拟 ret.c[i] = x.c[i] / y; x.c[i] %= y; x.c[i - 1] += x.c[i] * 10; } while (ret.c[lr] == 0 &amp;&amp; lr &gt; 1) lr--; ret.length = lr; return ret; } 附赠:高精max/高精快速幂/高精重载大于号inline node max(node x, node y) {//哈哈 return x &gt; y ? x : y;//重载运算符在下面 } bool operator &gt; (const node &amp;y) const { if (length == y.length) { int i; for (i = length; i &gt; 1 &amp;&amp; c[i] == y.c[i]; --i); if (i &gt;= 1) return c[i] &gt; y.c[i]; else return false; } else return length &gt; y.length; } inline node super_pow(int times) {//哈哈,其实没啥区别的 node ans, temp = base; memset(ans.c, 0, sizeof(ans.c)); ans.c[1] = 1, ans.length = 1; while (times) { if (times &amp; 1) ans = super_mul(ans, temp); temp = super_mul(temp, temp); times &gt;&gt;= 1; } return ans; }","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://yoursite.com/categories/经验总结/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"}],"author":"i-cookie"},{"title":"luogu P1966 火柴排队","slug":"火柴排队","date":"2019-10-11T16:00:00.000Z","updated":"2019-10-12T05:09:14.000Z","comments":true,"path":"2019/10/12/火柴排队/","link":"","permalink":"http://yoursite.com/2019/10/12/火柴排队/","excerpt":"","text":"NOIP的题就是好. 题面:P1966 [NOIP2013]火柴排队分析如果问我需要多少次交换能把一个序列排好序,我就可以直接用归并排序求逆序对.但是本题不走寻常路.我们先来分析一下题目. 题目要求$\\sum_{i=1}^{n}(a_i-b_i)^2$最小.我们应该把什么样的局面作为目标呢?类似于邻项交换类的贪心问题,假设我们有$a_1,a_2,b_1,b_2$这两个数组.其中$a_1&lt; a_2,b_1&lt; b_2$.现在我们有两种选择: 把$a_1$和$b_1$配对,那么两列火柴的距离就是$(a_1^2+b_1^2+a_2^2+b_2^2)-2(a_1b_1+a_2b_2)$ 把$a_1$和$b_2$配对,那么两列火柴的距离就是$(a_1^2+b_1^2+a_2^2+b_2^2)-2(a_1b_2+a_2b_1)$ 两式相减,不考虑常数,我们得到$-(a_1b_1+a_2b_2)+(a_1b_2+a_2b_1)$如果第二种选择比第一种选择得到的距离要更小,就意味着$$a_1b_2+a_2b_1&gt;a_1b_1+a_2b_2\\\\Rightarrow a_1(b_2-b_1)&gt;a_2(b_2-b_1)\\\\Rightarrow a_1&gt; a_2$$这不就矛盾了吗?所以假设不成立.那么只有把$a$种第$i$小的和$b$中第$i$小的排在相同的位置才行.换句话说,我们就要通过交换使得离散化后的$a_i=b_i$.当然了,离散化只是为了体现出排名,我们也可以进行其他的操作来达到相同的目的. 比如,我们设有一个函数$q()$,这个函数的功能是这样的:如果输入原$a$数列中第$i$小的数的位置,它就会返回原$b$数列中第$i$小的数的位置.这样就把两个应该相等化的值联系起来了.然后我们发现由于原序列已经给定,我们可以预处理出$q()$函数的可能的值,使得它变成$q[]$数组.具体怎么做呢? 我们用结构体的形式来储存两列火柴,结构体保存每根火柴的高度和在原序列中的下标.然后按照高度从小到大排序.这样得到的下标序列$a[i].ind$的意义就是原序列中第$i$小的数所在的位置.对b做同样的处理后,我们的$q$数组该怎么处理就显而易见了.输入$a[i].ind$返回$b[i].ind$,也就是$q[a[i].ind]=b[i].ind$. 如果我们通过交换来修改原序列,那么$a[i].ind$的值就会发生变化,$q$的值也会发生变化.我们最终的目的是$a[i].ind=b[i].ind$,那么就有$q[a[i].ind]=a[i].ind$即$q[k]=k(k=a[i].ind)$.这样一看,不就是让$q[1]=1,q[2]=2…$,把$q$排好序吗?而我们只能交换相邻项,所以求出$q$的逆序对个数就是答案了. 代码:#include &lt;cmath&gt; #include &lt;queue&gt; #include &lt;deque&gt; #include &lt;cctype&gt; #include &lt;string&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #define mod 9999997 #define int long long using namespace std; template&lt;class T&gt; inline void read(T &amp;x) { x = 0; char ch = getchar(), w = 0; while (!isdigit(ch)) w = (ch == &#39;+&#39;), ch = getchar(); while (isdigit(ch)) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); x = w ? x : x; return; } int n, q[100000], temp[100000], cnt; struct node { int val, ind; }a[100000], b[100000]; inline bool cmp1(node x, node y) { return x.val &lt; y.val; } inline bool cmp2(node x, node y) { return x.val &lt; y.val; } void merge_sort(int l, int r) { if (l == r) return; int mid = l + r &gt;&gt; 1; merge_sort(l, mid); merge_sort(mid + 1, r); int i = l, j = mid + 1, t = l; while (i &lt;= mid &amp;&amp; j &lt;= r) { if (q[i] &lt;= q[j]) temp[t] = q[i], i++; else { temp[t] = q[j], j++; cnt += (mid - i + 1); cnt %= mod; } t++; } while (i &lt;= mid) temp[t] = q[i], t++, i++; while (j &lt;= r) temp[t] = q[j], t++, j++; for (int k = l; k &lt;= r; ++k) q[k] = temp[k]; return; } signed main() { read(n); for (int i = 1; i &lt;= n; ++i) read(a[i].val), a[i].ind = i; for (int i = 1; i &lt;= n; ++i) read(b[i].val), b[i].ind = i; sort(a + 1, a + 1 + n, cmp1); sort(b + 1, b + 1 + n, cmp2); for (int i = 1; i &lt;= n; ++i) q[a[i].ind] = b[i].ind; merge_sort(1, n); cout &lt;&lt; cnt &lt;&lt; endl; return; } // 拒绝抄袭,从我做起 本题思路真是非常巧妙,尤其是$q$数组的设想,蒟蒻的我也是参考了好多题解和思路才得到了这种理解.思维的灵活性是真的重要啊.","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"}],"author":"i-cookie"},{"title":"勇于打破标签——luogu P3197 越狱","slug":"越狱","date":"2019-10-11T03:39:30.000Z","updated":"2019-10-11T03:43:28.000Z","comments":true,"path":"2019/10/11/越狱/","link":"","permalink":"http://yoursite.com/2019/10/11/越狱/","excerpt":"","text":"写这篇博客是为了警示自己别总是局限于标签.luogu典型的标签坑人系列. 题面:P3197 [HNOI2008]越狱这道题输入只有两个数,让人不禁怀疑这到底是道什么题.按照DP标签来搜题的我陷入了沉思.一看数据范围顿时就怂了,这是什么神题,于是默默打开了题解.然后我才意识到:$$\\textbf{这就是一道数学题,别怀疑自己了}$$由于直接算越狱的情况数并不方便,所以我们正难则反,用总的方案数减去不会越狱的方案数.总的方案数是多少呢?每个犯人有$M$种选择,一共有$N$个犯人,那么总方案数应该是$M^N$.然后如果不会越狱就代表相邻犯人信仰不同.我们按顺序考虑.对于左数第一个犯人,他有$M$种选择,而对于下一个犯人,显然只剩下了$M-1$种选择.那么对于下一个犯人是不是只剩下了$M-2$种选择呢?不是! 因为我们只要求相邻的不同,所以第三个犯人仍然可以选择第一个犯人的选择.那么还是$M-1$种.所以答案就是:$$M^N-M\\times (M-1)^{N-1} (mod\\ \\ 100003)$$谨以此博客祭奠我浪费在瞎想上的时间","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"数论,数学","slug":"数论-数学","permalink":"http://yoursite.com/tags/数论-数学/"}],"author":"i-cookie"},{"title":"字符串/序列类DP(三)","slug":"字符串DP3","date":"2019-10-11T02:16:15.000Z","updated":"2019-10-11T02:18:36.000Z","comments":true,"path":"2019/10/11/字符串DP3/","link":"","permalink":"http://yoursite.com/2019/10/11/字符串DP3/","excerpt":"","text":"$\\text{蒟蒻在DP之路上求索着}$ 题面:luogu P1018 乘积最大分析又是一道字符串相关的DP,其实我做这道题也是为了练习高精度乘法.题目中给了k个乘号,那么我们来考虑它们的位置.因为乘号位置的不同直接导致了结果的不同,所以我们设$f[i][j]$表示把$i$个乘号放到前$j$个数字之间,在前$j$个数字的范围内能得到的最大解.在考虑子问题的时候就好好考虑子问题,而不是同时挂念着整体. 那么假设我们现在已经放了$i-1$个乘号,手中拿着第$i$个乘号,我们应该怎么转移呢?我们枚举这个乘号的位置,因为可以放置乘号个数的上界是$min(k,j-1)$,所以我们可能有多个位置可以放.如果我们放在第$p$个数字和第$p+1$个数字之间,那么就把第$1$到$p$个和第$p+1$到$j$个数字分开了,我么只需要用$f[i-1][p]\\times num[p+1][j]$来更新答案就可以了.其中$num[p+1][j]$表示我们提取出来的数字. DP代码:for (int i = 1; i &lt;= n; ++i) for (int j = i; j; --j) f[0][i].c[++f[0][i].length] = a[j]; for (int i = 2; i &lt;= n; ++i) for (int j = 1; j &lt;= min(k, i - 1); ++j) for (int p = j; p &lt; i; ++p) f[j][i] = max(f[j][i], super_mul(f[j - 1][p], p + 1, i)); 当然了,我写这个题还是为了学高精度乘法,在上面的$max()$和$super_mul()$函数中. 高精度乘法代码:struct node { int length;//记录长度 int c[100];//记录答案(倒序) }f[10][100]; inline node super_mul(node a1, int l, int r) { node ret, b;//暂存器 memset(ret.c, 0, sizeof(ret.c)); memset(b.c, 0, sizeof(b.c)); b.length = r - l + 1; for (int i = r; i &gt;= l; --i)//储存乘数 b.c[r - i + 1] = a[i]; int la = a1.length, lb = b.length; for (int i = 1; i &lt;= la; ++i)//由于没有压位不担心爆炸所以直接乘 for (int j = 1; j &lt;= lb; ++j) ret.c[i + j - 1] += a1.c[i] * b.c[j]; int lr = la + lb - 1; for (int i = 1; i &lt;= lr; ++i) {//乘完了再进位 ret.c[i + 1] += ret.c[i] / 10; ret.c[i] %= 10; } if (ret.c[lr + 1]) lr++; ret.length = lr; return ret; } inline node max(node x, node y) {//比较两个长整数的大小 int lx = x.length, ly = y.length; if (lx &gt; ly) return x; if (lx &lt; ly) return y; for (int i = lx; i; --i) { if(x.c[i] &gt; y.c[i]) return x; if(x.c[i] &lt; y.c[i]) return y; } return x; }","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"}],"author":"i-cookie"},{"title":"数列分块(完结于2019.10.10)","slug":"数列分块(upd2019.10.9)","date":"2019-10-10T10:53:00.000Z","updated":"2019-10-10T10:53:08.000Z","comments":true,"path":"2019/10/10/数列分块(upd2019.10.9)/","link":"","permalink":"http://yoursite.com/2019/10/10/数列分块(upd2019.10.9)/","excerpt":"","text":"分块是优雅的暴力——一位$dalao$ hzwer dalao的blog$Level\\ \\ 1$题面给出一个长为$n$的数列，以及$n$个操作，操作涉及区间加法，单点查值。 数据范围与约定对于$100$%的数据,$1\\le n\\le 50000,others/ans\\in INT$ 题解作为分块的第一题,它具有最小的难度和最强的代表性.题目要求区间修改单点查询,事实上通过树状数组也是可以完成的.那么接下来我们看看分块怎么做. 分块就像字面意思,把数列分成若干块,使得信息的统计和修改更加容易不必精确到点,节省了时间.分块主要分两种情况讨论: 不完整的块只需要靠暴力来扫即可. 完整的块可以做整体操作来节省时间,这也是分块和暴力相比最优越的地方. 分多少块呢?如果我们每块的大小是$size$,则处理每一整块需要$\\Theta(1)$的复杂度,一共有$n/m$块,两边不完整的块最多有$2m$个元素,所以复杂度是$\\Theta(n/m)+\\Theta(m)$,根据均值不等式,我们可以得出当分$\\sqrt{n}$块时复杂度是最小的.可以通过代码来感受一下分块过程: struct node { int tag, l, r; }part[N];//块结构体 ... int size = sqrt(n)//每块的大小; part[1].l = 1; for (int i = 1; i &lt;= n; ++i) { bel[i] = cnt;//序列中第i个位置属于第几块 if (i % size == 0) {//一整块 part[cnt].r = i; part[++cnt].l = i + 1;//增加新的块 } } part[cnt].r = n; 接下来我们回到问题,来分析一下该怎么实现区间修改和单点查询.因为要按块来整体操作,所以我们对每一个块打一个$tag$,表示加法标记.当我们的区间修改覆盖整块的时候,我们直接令这一块的$tag$增加.如果不是一整块就暴力扫描.当我们要单点查询的时候,只需要让数列中的值加上它所属的块的加法标记即可. read(opt); if (opt) { int x, y, z; read(x), read(y), read(z); printf(&quot;%lld\\n&quot;, a[y] + part[bel[y]].tag);//输出只需要加上加法标记. } else {修改需要判定一些边界,如是不是完整块,左右端点是不是在同一块中. int x, y, z; read(x), read(y), read(z); if (part[bel[x]].l == x &amp;&amp; part[bel[y]].r &lt;= y) part[bel[x]].tag += z;//如果左端点恰好是一块的起点,区间覆盖一整块就直接加 else for (int i = x; i &lt;= min(part[bel[x]].r, y); ++i) a[i] += z;//x,y可能同块,所以要取min if (bel[x] == bel[y]) continue; if (part[bel[y]].r == y &amp;&amp; part[bel[y]].l &lt;= x) part[bel[y]].tag += z; else for (int i = y; i &gt;= part[bel[y]].l; --i) a[i] += z; for (int i = bel[x] + 1; i &lt;= bel[y] - 1; ++i) part[i].tag += z;//把剩下的块直接处理 } 这样我们就完成了第一个分块题. $Level\\ \\ 2$题面给出一个长为n的数列，以及n个操作，操作涉及区间加法，询问区间内小于某个值x的元素个数。 数据规模与约定对于$100$%的数据,$1\\le n\\le 50000,others/ans\\in INT$. 题解这道题就不是用各种数据结构都可以维护的了.我们考虑如何把数列分成一块一块的来分别处理. 首先我们根据分块的原则,如果处理的区间没有覆盖一个完整的块,我们就用暴力来扫描,反正也花不了多少时间.如果覆盖一个完整的块,我们又该怎么处理呢?类似于求区间第k小的操作,我们是通过二分查找来看区间中有多少个数符合要求的.但是二分的前提是区间内的数是单调的.但是又不能直接给原序列排序,怎么办呢?我们可以保存一个原序列的副本,然后分完块后对每一块排序,这样如果不能覆盖完整块,就在原序列上暴力扫,如果覆盖了完整块,就在有序的副本上二分查找得出答案. 询问部分的代码: if (op) { int x, y, z; read(x), read(y), read(z), z *= z; if (bel[x] == bel[y]) { int tot = 0; for (int i = x; i &lt;= y; ++i) tot += (a[i] + part[bel[x]].tag &lt; z); printf(&quot;%d\\n&quot;, tot); } else { int tot = 0; if (part[bel[x]].l == x) tot += ef_find(part[bel[x]].l, part[bel[x]].r, z) - part[bel[x]].l; else { for (int i = x; i &lt;= part[bel[x]].r; ++i) tot += (a[i] + part[bel[x]].tag &lt; z); } if (part[bel[y]].r == y) tot += ef_find(part[bel[y]].l, part[bel[y]].r, z) - part[bel[y]].l; else { for (int i = y; i &gt;= part[bel[y]].l; --i) tot += (a[i] + part[bel[y]].tag &lt; z); } for (int i = bel[x] + 1; i &lt;= bel[y] - 1; ++i) tot += ef_find(part[i].l, part[i].r, z) - part[i].l; printf(&quot;%d\\n&quot;, tot); } } 还有修改呢?参考上一题,我们发现可以维护一个加法标记.但是不完整的块加完之后不一定是递增的,因此要对这一块重新排序来获取单调性.在整个过程中要保持有序副本和原数列的高度同步,不然很容易错. 修改部分的代码: else { int x, y, z; read(x), read(y), read(z); if (part[bel[x]].l == x &amp;&amp; part[bel[x]].r &lt;= y) part[bel[x]].tag += z; else { for (int i = x; i &lt;= min(part[bel[x]].r, y); ++i) a[i] += z; for (int i = part[bel[x]].l; i &lt;= part[bel[x]].r; ++i) sed[i] = a[i]; sort(sed + part[bel[x]].l, sed + part[bel[x]].r + 1); } if (bel[x] == bel[y]) continue; if (part[bel[y]].r == y &amp;&amp; part[bel[y]].l &gt;= x) part[bel[y]].tag += z; else { for (int i = y; i &gt;= part[bel[y]].l; --i) a[i] += z; for (int i = part[bel[y]].l; i &lt;= part[bel[y]].r; ++i) sed[i] = a[i]; sort(sed + part[bel[y]].l, sed + part[bel[y]].r + 1); } for (int i = bel[x] + 1; i &lt;= bel[y] - 1; ++i) part[i].tag += z; } 这就是第二题了. $Level\\ \\ 3$题面给出一个长为n的数列，以及n个操作，操作涉及区间加法，询问区间内小于某个值x的前驱（比其小的最大元素）。 数据规模与约定对于$100$%的数据,$1\\le n\\le 100000,others,ans\\in INT$ 题解其实这个题和上一题基本一样,主要是数据范围方面更加筛掉了暴力.我们只需要稍微改动一下上一题的二分,再改一改对应的操作就可以了. $Level\\ \\ 4$题面给出一个长为n的数列，以及n个操作，操作涉及区间加法，区间求和。 数据规模与约定对于$100$%的数据,$1\\le n\\le 50000,others,ans\\in INT$ 题解经典的线段树问题.数据范围比较小,所以我们考虑用分块来做(废话).仍然是区间加法,所以我们还是像往常一样,打好标记.但是这次需要注意的是我们要随时维护区间的和,像线段树那样给每一块打上一个和标记,当需要询问整块信息的时候直接调用即可.否则就暴力处理.需要注意许多初始化,打标记和修改的细节.由于代码冗长且与之前的题目相差无几,我就不再出示代码. $Level \\ \\ 5$题面给出一个长为n的数列，以及n个操作，操作涉及区间开方，区间求和。 数据规模与约定对于$100$%的数据,$1\\le n\\le 50000,others,ans\\in INT$ 题解又是一道经典的线段树问题.区间开方是不满足合并的,换句话说,区间中每个数开方不相当于区间和开方.但是我们注意到一个边界性的问题,就是0开方后仍然是0,1开方后还是1.而其他数经过至多5次开方后也会变成1.所以我们在无法整块操作的情况下仍然可以给区间打上一个$times$标记表示这个区间被整体开方过多少次.如果超过4次我们就直接给答案加上$\\text{原序列中非0数的个数-原序列中0的个数}$就可以了.其他情况下我们仍然暴力开方.上代码: for (int i = 1; i &lt;= n; ++i) { int op, x, y, z; read(op), read(x), read(y), read(z); if (op) {//询问操作 long long res = 0; if (bel[x] == bel[y]) for (int j = x; j &lt;= y; ++j) res += a[j]; else { for (int j = x; j &lt;= part[bel[x]].r; ++j) res += a[j]; for (int j = y; j &gt;= part[bel[y]].l; --j) res += a[j]; } for (int j = bel[x] + 1; j &lt;= bel[y] - 1; ++j) { if (part[j].times &gt; 4)//times表示被整体开方的次数 res += part[j].r - part[j].l + 1 - part[j].ze; else //ze表示原序列中0的个数 for (int k = part[j].l; k &lt;= part[j].r; ++k) res += a[k]; } printf(&quot;%lld\\n&quot;, res); } else {//修改操作 if (bel[x] == bel[y]) for (int j = x; j &lt;= y; ++j) a[j] = sqrt(a[j]); else { if (part[bel[x]].l == x) { if (part[bel[x]].times &lt;= 4) for (int j = part[bel[x]].l; j &lt;= part[bel[x]].r; ++j) a[j] = sqrt(a[j]); part[bel[x]].times++; } else for (int j = x; j &lt;= part[bel[x]].r; ++j) a[j] = sqrt(a[j]); /*为了节省篇幅,对y的操作类比省略.*/ } for (int j = bel[x] + 1; j &lt;= bel[y] - 1; ++j) { if (part[i].times &lt;= 4) for (int k = part[j].l; k &lt;= part[j].r; ++k) a[k] = sqrt(a[k]); part[j].times++; } } } $Level\\ \\ 6$题面给出一个长为n的数列，以及n个操作，操作涉及单点插入，单点询问，数据随机生成。 数据规模与约定对于$100$%的数据,$1\\le n\\le 100000,others,ans\\in INT$ 题解这道题画风突变,出现了一个闻所未闻的”插入”操作.对于数组来说,要插入一个数,就要花费$\\Theta(n)$的时间来把后面的元素都往后移一位.而对于链表来说,想要定位一个数则需要$\\Theta(n)$的时间.这道题可以使用对二者取长补短的块状链表来实现,不过我不会而且我们的主题是分块,所以我们来想想分块的做法. 由于分块是在数组上实现的,所以插入操作难免会需要暴力.不过普通数组的暴力需要把插入点后面所有的元素都移动,而分块只需要把组内插入点之后的元素移动就可以了.那么我们怎么实现插入呢?暴力是可以的,但我认为更好的选择是使用$STL$的$vector$,这个容器支持$insert$函数,并且能够随时记录自己的$size$. 但是这样有一个问题,如果数据并非随机生成的,而是在一个块内各种插入,那么分块将逐渐退化为普通数组,进而T到飞起.所以我们考虑每$\\sqrt{n}$次插入操作就把数列重新分一下块,使得复杂度不会提高很多.(为什么要每$\\sqrt{n}$次就重排一次的原因请参考hzwer dalao的blog)并且重排之前别忘了把现在每一块中的$vector$内容赋值到原数组中.代码: #include&lt;bits/stdc++.h&gt; #define N 200005//由于插入操作别忘了数组开大一点 using namespace std; /*篇幅原因,快读省略*/ int n, a[N], cnt = 1; struct node { int l, r; vector&lt;int&gt; c;//每个块的动态数组 }part[2000]; inline void reset() {//重分块函数 int size = sqrt(n); part[1].l = 1, cnt = 1; for (int i = 1; i &lt;= n; ++i) { part[cnt].c.push_back(a[i]); if (i % size == 0) { part[cnt].r = i; part[++cnt].l = i + 1; } } part[cnt].r = n; return; } inline void react() {//别忘了先把原数组更新为现在的样子. n = 0; for (int i = 1; i &lt;= cnt; ++i) { if (part[i].c.empty()) continue; for (int j = 0; j &lt; part[i].c.size(); ++j) a[++n] = part[i].c[j]; part[i].c.clear(); } reset();//现在可以重分块了 return; } int main() { read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); reset();//先分块 int temp = n, tot = 0; while (temp--) { int op, x, y, z; read(op), read(x), read(y), read(z); if (op) { int i; for (i = 1; i &lt;= cnt; ++i)//查询过程,先定位块 if (y &gt; part[i].c.size()) y -= part[i].c.size(); else break;//定位完后剩下的就是块内的编号了. printf(&quot;%d\\n&quot;, part[i].c[y - 1]); } else { tot++;//记录次数 for (int i = 1; i &lt;= cnt; ++i) if (x &gt; part[i].c.size()) x -= part[i].c.size(); else { part[i].c.insert(part[i].c.begin() + x - 1, y);//插入 if (tot &gt; sqrt(n))//如果插入次数多了就重分块 react(), tot = 0; break; } } } return 0; } $Level\\ \\ 7$题面给出一个长为n的数列，以及n个操作，操作涉及区间乘法，区间加法，单点询问。 数据规模与约定对于$100$%的数据,$1\\le n\\le 100000,others,ans\\in INT$ 题解这道题的画风逐渐正常,又是一道经典的线段树问题.线段树在维护这两种操作的时候,打了两种标记,所以分块也打了两种标记.但是这两种标记显然是有区别的.因为乘法运算的优先级高于加法.那么我们怎么来维护呢?假设现在一块上先乘后加,得到一个加法标记和一个乘法标记.那么我们考虑如果现在进行整块的加,会发生什么呢?显然,只有加法标记会增加,而影响不到乘法标记.那如果进行乘法呢?乘法和加法标记都需要乘上这个数.所以我们按照这个优先顺序进行整块的操作,非整块的时候我们只能通过把这一块重构暴力来做.块内重构: inline void rebuild(int x) { for (int i = part[x].l; i &lt;= part[x].r; ++i) a[i] = (a[i] * part[x].tagm + part[x].taga) % mod; part[x].taga = 0, part[x].tagm = 1; return; } 其他代码和之前的类似. $Level\\ \\ 8$题面给出一个长为n的数列，以及n个操作，操作涉及区间询问等于一个数c的元素，并将这个区间的所有元素改为c。 数据规模与约定对于$100$%的数据,$1\\le n\\le 100000,others,ans\\in INT$ 题解到了这个题我才知道,原来块内重构是非常常见的,是我之前把它的复杂度想得太高,结果代码冗长时间也没有节省很多.这个题的询问非常奇怪,又是一个线段树维护不了的题目.分块源于暴力而高于暴力,所以它问什么我们打什么标记.我们给每个块打一个”块内元素是否全部相等,如果相等的话,等于什么”的标记.这个标记听起来很玄学,实际上,当块内标记都相等时,这个标记就赋值为块内的值,否则就赋值为$-inf$.这样我们每当遇到一个区间内有不同元素的块的时候,都要用暴力来统计.这看起来会T(实际上像我一样写丑了也会T),实际上每一块这一次扫完之后,就被赋值成一样的了.下次整块操作的时候就可以直接$\\Theta(1)$统计答案了.所以总的复杂度是可以接受的. $Level\\ \\ 9$题面给出一个长为n的数列，以及n个操作，操作涉及询问区间的最小众数。 数据规模与约定对于$100$%的数据,$1\\le n\\le 100000,others,ans\\in INT$ 题解来到了$BOSS$关.区间众数是一道经典难题.有的许多方法.这里讲一种基于分块的在线做法. 分块的难点在于它不具有区间可加性.也就是知道两块的众数并不能直接得出这两块整体的众数.但是判断众数的本质是一个数出现的次数,这是满足区间可加性的.我们考虑从这方面来下手.对于分块,我们一贯的思路是整块统计,两端暴力.这一道题也不例外.我们的众数要么是在整块统计中得出的,要么是在两端的暴力过程中得出的.所以对于整块,我们直接统计众数,然后暴力扫描两端看能不能取代已经得到的答案. 现在问题来了,怎么统计若干块之间的众数呢?如果要快速得出,我们肯定不能现问现扫,而是要预处理出来再做.因为区间长度是任意的,我们也应当处理出连续多块之间的众数.前面说了众数的本质是出现次数.我们设t[i][j]表示i在前j块中的出现次数.为了方便统计我们要先离散化以下,让i表示第i小的数.然后固定一个最右边的块,向左扫描到整个序列的左端,中途维护众数,这里出示代码来加强理解: for (int i = 1; i &lt;= bel[n]; ++i) {//most[i][j]表示第i块到第j块的最小众数. for (int j = rt[i]; j; --j) {//t[i][j]表示i在前j块中出现的次数,类似于前缀和 if (bel[j] != bel[j + 1])//区间分界线先继承一下,方便对比 most[bel[j]][i] = most[bel[j] + 1][i]; t[lsh[j].rk][i]++;//出现次数+1 int nowtemp = t[lsh[j].rk][i], nowans = t[most[bel[j]][i]][i];//检验是否能够取代 if (nowtemp &gt; nowans || (nowtemp == nowans &amp;&amp; lsh[j].rk &lt; most[bel[j]][i])) most[bel[j]][i] = lsh[j].rk;//次数多或者次数相等值小就可以取代. } } 现在我们已经知道如何预处理众数了.做法比较暴力.接下来我们就考虑询问.实际上过程是完全类似的.这里直接上代码,并不难理解. //ap[i]表示i出现的次数,是一个暂存数组 int x, y, ans; read(x), read(y), ans = most[bel[x] + 1][bel[y] - 1]; if (bel[x] == bel[y]) { for (int i = x; i &lt;= y; ++i) { ++ap[lsh[i].rk]; int nowtemp = ap[lsh[i].rk], nowans = ap[ans]; if (nowtemp &gt; nowans || (nowtemp == nowans &amp;&amp; lsh[i].rk &lt; ans)) ans = lsh[i].rk; } printf(&quot;%d\\n&quot;, ans = rev[ans]);//别忘了ans其实是一个离散化后的排名 } else { //这里通过t数组后减去前来实现中间完整块内出现次数的统计,因为次数满足可加性 for (int i = x; i &lt;= rt[bel[x]]; ++i) { ++ap[lsh[i].rk]; int nowtemp = ap[lsh[i].rk] + t[lsh[i].rk][bel[y] - 1] - t[lsh[i].rk][bel[x]]; int nowans = ap[ans] + t[ans][bel[y] - 1] - t[ans][bel[x]]; if (nowtemp &gt; nowans || (nowtemp == nowans &amp;&amp; lsh[i].rk &lt; ans)) ans = lsh[i].rk; } for (int i = lt[bel[y]]; i &lt;= y; ++i) { ++ap[lsh[i].rk]; int nowtemp = ap[lsh[i].rk] + t[lsh[i].rk][bel[y] - 1] - t[lsh[i].rk][bel[x]]; int nowans = ap[ans] + t[ans][bel[y] - 1] - t[ans][bel[x]]; if (nowtemp &gt; nowans || (nowtemp == nowans &amp;&amp; lsh[i].rk &lt; ans)) ans = lsh[i].rk; } printf(&quot;%d\\n&quot;, ans = rev[ans]); } for (int i = x; i &lt;= rt[bel[x]]; ++i) ap[lsh[i].rk] = 0;//清空暂存器 for (int i = lt[bel[y]]; i &lt;= y; ++i) ap[lsh[i].rk] = 0; 这就是经典的区间众数问题了.到此我们已经完成了所有的分块入门模板题,体会到分块的原则就是整块统计,两端暴力.通过打标记和块内重构的方法,在保证正确性地情况下来尽量方便省时地实现目的.其时间复杂度往往劣于线段树等高级数据结构,但是其灵活性并不差,并且非常直观. 感谢@suwakow给予的帮助和参考 $\\textit{Fin}$","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://yoursite.com/categories/经验总结/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"分块","slug":"分块","permalink":"http://yoursite.com/tags/分块/"}],"author":"i-cookie"},{"title":"整体二分初步","slug":"整体二分初步","date":"2019-10-04T11:53:39.000Z","updated":"2019-10-09T06:36:44.000Z","comments":true,"path":"2019/10/04/整体二分初步/","link":"","permalink":"http://yoursite.com/2019/10/04/整体二分初步/","excerpt":"","text":"这大概是我目前学过的最难理解的知识点了吧( 概述 整体二分,意味着同时二分一切 这个算法适用于静态和动态区间第$k$大,以及一些区间询问问题.那么根据通常的思路,让我们先来介绍一下暴力,再来分析二者的区别. 静态区间第k大让我们暴力地二分答案来做,应该怎么做呢?既然我们要求区间第$k$大,那么区间中就应该有$k-1$个数比答案大才对.所以我们二分答案$mid$,看看序列里有多少个比它小的数,然后缩小值域. 想象一下,如果对于每一个询问操作我们都这样做,会$T$成什么样子.对于每个操作都要做相同的二分,会出现大量的时间浪费.那么我们最好能一次性处理所有的操作.这时候就要用到整体二分了! 机制对于答案的二分还是依旧,只不过这次不是针对一个操作了.我们把各个操作排成一列,和二分同步进行.这里我们设计一个函数$solve(ql,qr,l,r)$,表示我们把某些操作放到”符合答案在区间$[l,r]$中”的区域,根据值域进行二分答案,并把它们分别标号$[ql,qr]$来方便递归分组.现在我们来考虑怎么分组以及分组过程中的事情. 首先,如果$l=r$了的话,代表区间所属询问的答案在区间$[l,l]$中,那就直接记录答案即可.然后如果还没到最后,我们就要像暴力那样二分出mid,然后扫一遍对应的数看一看有多少数大于mid,然后接下来就是看操作如何分组了. 每个操作都询问一个区间,针对一个区间的时候我们可以直接做,那么针对许多区间呢?我们可以用树状数组的方式,通过前缀和相减来迅速确认有多少个是大于mid的.如果大于k,代表答案应该还在左边,所以把这个操作放到左边,否则放到右边,具体可以通过开两个数组暂存来实现.最后像归并排序一样把这些暂存器里的操作按已经分好的左右放回操作序列,并根据分的左右来递归左边多少,右边多少. #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; int sum[5000050],n,m,cnt,answer[5000050]; const int oo=1e9; struct node { int a,b,k,id,type; }q[5000050],q1[5000050],q2[5000050]; /****************BIT*************/ int lowbit(int x) { return x&amp;(-x); } void add(int pos,int w) { for(int i=pos;i&lt;=n;i+=lowbit(i))sum[i]+=w; } int ask(int pos) { int ans=0; for(int i=pos;i;i-=lowbit(i))ans+=sum[i]; return ans; } /****************BIT**************/ void solve(int ql,int qr,int l,int r)//假设答案在[l,r]中,符合答案属于[l,r]的操作序列是[ql,qr] { if(ql&gt;qr)return; if(l==r)//如果答案已经确定 { for(int i=ql;i&lt;=qr;i++)//区间中所有的操作答案都已经确定 if(q[i].type==2) answer[q[i].id]=l; return ; } int cnt1=0,cnt2=0; int mid=(l+r)&gt;&gt;1;//二分答案 for(int i=ql;i&lt;=qr;i++)//扫一遍这个操作和数的混合序列,进行分组和重新混合 if(q[i].type==1)//如果是数 { if(q[i].a&lt;=mid)//考虑它应该放在哪个操作区间继续下传 q1[++cnt1]=q[i],//q1是将要下放到左区间的暂时储存器 add(q[i].id,1);//加到树状数组,之后求前缀和 else q2[++cnt2]=q[i];//放到右边先不管 } else//由于读入的顺序,数一定先于操作来处理. { int tmp=ask(q[i].b)-ask(q[i].a-1);//用树状数组统计当前有多少小于mid的 if(q[i].k&lt;=tmp)//如果小于tmp个,就代表答案在[l,mid] q1[++cnt1]=q[i]; else q2[++cnt2]=q[i],//否则在[mid+1,r] q2[cnt2].k-=tmp;//此时应减去cmp } for(int i=1;i&lt;=cnt1;i++){//还原树状数组 if(q1[i].type==2) break; add(q1[i].id,-1); } for(int i=1;i&lt;=cnt1;i++)//赋值回原数组,类似于归并排序 q[i+ql-1]=q1[i]; for(int i=1;i&lt;=cnt2;i++) q[i+ql+cnt1-1]=q2[i]; solve(ql,ql+cnt1-1,l,mid);//递归下去直到确定答案 solve(ql+cnt1,qr,mid+1,r); return; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;q[++cnt].a),//读入序列 q[cnt].id=i,//储存下标 q[cnt].type=1;//代表这是一个数 for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;q[++cnt].a),//离线读入所有操作 scanf(&quot;%d&quot;,&amp;q[cnt].b), scanf(&quot;%d&quot;,&amp;q[cnt].k), q[cnt].id=i,//储存下标 q[cnt].type=2;//代表这是一个操作 solve(1,cnt,-oo,oo); for(int i=1;i&lt;=m;i++) cout &lt;&lt; answer[i], printf(&quot;\\n&quot;); return 0; } 动态区间K大相比于静态,动态只需要加一点操作,就是当扫到修改的时候,如果修改后的值$\\le mid$,才能放到左区间,而且要先执行以下免得后面的判断不符合事实. 其他问题[POI2011]MET-Meteors在该问题中,我们首先要做的是断环成链,使得问题变成序列问题.操作区间右端点小于左端点时,将右端点+m即可. 这次我们二分的答案是每个国家最早什么时候收集到足够的陨石.因此我们二分出答案mid后,要让$[l,mid]$的陨石雨都落下来(也就是在树状数组上上传),然后按照哪些国家收集足够了为标准,对询问分类即可.值得注意的是,因为一个国家的空间站可能是分散在环上的,所以我们可以通过连边的方式来统一.同时因为是区间加,所以树状数组应维护差分数组. 在判断某个国家是否被满足的时候,应当扫过它的每个空间站$j$,然后将$sum(j)$与$sum(j+m)$相加来作为判断它有没有收集足够的标准.为什么呢?因为每场流星雨代表数列上一个点加$a$,一个点减去$a$,如果左端点小于右端点,那么$sum(j+m)$在后半段,一定是$0$,此时答案是$sum(j)$.如果左端点大于右端点,那么右端点在后半段,左右端点相差不到$m$.那么如果$j$在左端点右边,$j+m$一定在右端点右边,统计同上一种情况.如果$j$在左端点左边,$j+m$要么在右端点右边,$sum(j)=sum(j+m)$,符合这次陨石雨没有影响到这个空间站的情况,要么在右端点左边,此时$sum(j)$一定位0,答案是$sum(j+m)$. #include &lt;cmath&gt; #include &lt;queue&gt; #include &lt;deque&gt; #include &lt;cctype&gt; #include &lt;string&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #define N 600005 #define int long long using namespace std; template&lt;class T&gt; inline void read(T &amp;x) { x = 0; char ch = getchar(), w = 0; while (!isdigit(ch)) w = (ch ==&#39;-&#39;), ch = getchar(); while (isdigit(ch)) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); x = w ? -x : x; return; } struct node { int head, ind, tot; }sta[N], stal[N], star[N]; struct NODE { int l, r, a; }eve[N]; int n, m, noe, k; int nxt[N], to[N]; int bit[N], ans[N]; inline int lowbit(int x) { return -x &amp; x; } inline void add(int x, int v) { while (x &lt;= m + m) bit[x] += v, x += lowbit(x); return; } inline int sum(int x) { int ret = 0; while (x) ret += bit[x], x -= lowbit(x); return ret; } inline void addedge(int from, int t) { nxt[++noe] = sta[from].head; to[noe] = t; sta[from].head = noe; return; } void solve(int l, int r, int ql, int qr) { if (l &gt; r) return; if (l == r) { for (int i = ql; i &lt;= qr; ++i) ans[sta[i].ind] = l; return; } int mid = l + r &gt;&gt; 1, tl = 0, tr = 0; for (int i = l; i &lt;= mid; ++i) { add(eve[i].l, eve[i].a); add(eve[i].r + 1, -eve[i].a); } for (int i = ql; i &lt;= qr; ++i) { int temp = 0; for (int j = sta[i].head; j &amp;&amp; temp &lt;= sta[i].tot; j = nxt[j]) temp += sum(to[j] + m) + sum(to[j]); if (temp &gt;= sta[i].tot) stal[++tl] = sta[i]; else star[++tr] = sta[i], star[tr].tot -= temp; } for (int i = l; i &lt;= mid; ++i) { add(eve[i].l, -eve[i].a); add(eve[i].r + 1, eve[i].a); } for (int i = 1; i &lt;= tl; ++i) sta[ql + i - 1] = stal[i]; for (int i = 1; i &lt;= tr; ++i) sta[ql + tl + i - 1] = star[i]; solve(l, mid, ql, ql + tl - 1), solve(mid + 1, r, ql + tl, qr); return; } signed main() { read(n), read(m); for (int i = 1, x; i &lt;= m; ++i) read(x), addedge(x, i); for (int i = 1; i &lt;= n; ++i) read(sta[i].tot), sta[i].ind = i; read(k); for (int i = 1; i &lt;= k; ++i) { read(eve[i].l), read(eve[i].r), read(eve[i].a); if (eve[i].r &lt; eve[i].l) eve[i].r += m; } solve(1, k + 1, 1, n); for (int i = 1; i &lt;= n; ++i) if (ans[i] &gt; k) printf(&quot;NIE\\n&quot;); else printf(&quot;%d\\n&quot;, ans[i]); return 0; } 感谢@SWK和@Tian-Xing两位dalao的帮助和陪伴","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://yoursite.com/categories/经验总结/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"整体二分","slug":"整体二分","permalink":"http://yoursite.com/tags/整体二分/"}],"author":"i-cookie"},{"title":"10月4日图论+DP","slug":"图论+DP10.4","date":"2019-10-04T10:20:17.000Z","updated":"2019-10-09T06:35:06.000Z","comments":true,"path":"2019/10/04/图论+DP10.4/","link":"","permalink":"http://yoursite.com/2019/10/04/图论+DP10.4/","excerpt":"","text":"T1problem给出一张n个点,m条边的又向带权图.要求找一条从1到n且边权递增的最短路. ans设disi表示1到i号边权递增的最短路长度.把边从小到大排序,每次加入一条边(u,v,w),考察dis(u)是否已经存在一个有意义的值,如果可用则用dis(u)+w去更新dis(v). T2problem给出一个N个点的无向图,其中1是首都.现在有两种边:m条道路,每条链接两个节点.k条铁路,每条链接首都和另外一个点.边有边权.问删去多少条铁路可以使得首都到所有点最短路都不变. ansT3problem给定一个N个点M条边的无向图.定义d(i,j)表示两点间的最短路.每个点定义了点权ai.现在对于图中每个点,你都需要计算:$$min_{j=1}^{n}(2\\times d(i,j)+a_j)$$ ans由于数据范围巨大,我们只能跑一遍最短路.因此每个i只能作为汇点(终点).所以我们建立一个超级原点向所有点建立边权为ai的边,跑一边最短路,通过这种操作,我们就可以直接求出d(i).而题目中的式子可以转化成:$$f[i]=min_{j=1}^{n}(d(0,j)+d(j,i))=d(i)\\text{(边权已变成二倍)}$$所以这道题就做完了 T4problem给出一张n个点,m条边的无向带权图.其中有k个关键点.求这k个关键点两两之间最短路的最小值. ans首先我们引入一个经典模型,如果要求图上连接两个点集的最短路,我们只需要建立一个超级源,向其中一个集合所有点链接边权为0的边然后跑最短路.那么在这个题中,我们要通过将K个关键点两两之间都至少一次分到两个集合中,来求出最小值. 那么怎么分组呢?我们考虑k个关键点的标号的二进制中至少有一位不同.所以按照二进制位来分组. Tproblem给出一张$n\\times m$的网格图,其中每个点可能是障碍,空地,A的基地,B的基地,C的基地.现在ABC随机选一个基地作为起点,然后他们会选择一个空地会合,选择的这个点必然是他们三个人前往的距离总和最小的点. 求这个距离总和的期望大小(AB基地的总数&lt;=50) ansT6problem有一张图,每条边的边权分别是关于时间的不同的二次函数.求最小生成树.假设没有负权边. ansT7problem问1-N中所有数转化为二进制数之后1的个数之积. ans令f[i][j][k]表示现在在第i位,数位中有j个1,跟上界之间的大小关系K.如果第i位取0,$f[i-1][j][k]\\Rightarrow f[i][j][k|N(i)]$.如果第i位取1,那么$f[i-1][j][k]\\times max(k,N(i))\\Rightarrow f[i][j+1][k]$ T8problem","categories":[{"name":"课堂笔记","slug":"课堂笔记","permalink":"http://yoursite.com/categories/课堂笔记/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}],"author":"i-cookie"},{"title":"10月3日数据结构","slug":"数据结构10.3","date":"2019-10-03T03:22:57.000Z","updated":"2019-10-09T06:33:30.000Z","comments":true,"path":"2019/10/03/数据结构10.3/","link":"","permalink":"http://yoursite.com/2019/10/03/数据结构10.3/","excerpt":"","text":"T1problem[NOIP2016]蚯蚓 ans我们可以观察到,对于两条蚯蚓,他们切开后对应段的长度顺序和切之前一样.所以我们按照长度顺序从大到小排序,然后维护三个队列.分别放完整的蚯蚓,切完后的一段和另一段.这样能够保证单调性.然后每次取出最大的队头处理.至于长度的增加,每条蚯蚓设置一个时间戳即可. T2problem有$n$块石头围成一个环,第$i$块石头高度为$a[i]$,两块不同的石头$i,j$互相能够看到当且仅当他们在环上的两条路径中至少有一条路径满足除了这两个点以外其他石头的高度都不大于$min(a[i],a[j])$.求有多少对石头能互相看到. ans我们仔细观察可以发现一条性质:如果我们找到了最大值所在的位置,那么其他任何$i,j$都不会选择经过最大值的这条弧.所以我们直接删掉这个最大值,问题就变成了链. 两个点能互相看到的条件是对于两个点$i&lt;j,i$右边到$j$为止都没有比$i$大的,$j$左边到$i$为止都没有比$j$大的.所以我们设置两个数组$left$和$right$.表示左边或者右边第一个比当前大的值的位置.那么如果$right[a[i]]&gt;j,left[a[j]]&lt;i,i$和$j$就能看到这可以通过单调栈在$\\Theta(n)$时间内解决.还有一种特殊情况是$a[i]=a[j]$,这时候我们对于栈的元素不再记录石头的编号和高度,而是记录高度以及石头个数.也就是当$a[i]=a[x]$时,我们不让$i$入栈,而让$tot[top]++$,其中$tot[top]$为$top$位置的石头有多少个.这样,每次出现这种情况,直接给答案加上$tot[top]-1$即可. T3problem有n个城市和m调公路,每条公路的价格是ci,有q次询问,每次询问在只用[l,r]编号的公路,在连通块数量尽量少的情况下,花费最少多少. ans","categories":[{"name":"课堂笔记","slug":"课堂笔记","permalink":"http://yoursite.com/categories/课堂笔记/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}],"author":"i-cookie"},{"title":"10月2日二分与倍增","slug":"二分倍增10.2","date":"2019-10-02T08:39:23.000Z","updated":"2019-10-09T06:32:12.000Z","comments":true,"path":"2019/10/02/二分倍增10.2/","link":"","permalink":"http://yoursite.com/2019/10/02/二分倍增10.2/","excerpt":"","text":"二分通常分为两类:二分查找和二分答案. T1problem给出一个数列$a[1…n]$,现在有m个询问,每次询问比x大的最小的$a[i]$的值. ans离线:数列和询问都排序,然后扫一遍. 在线:排序,二分查找. T2problem定义一个区间的值为其众数出现的次数.先给出一个数列$a[1…n]$,求在所有区间的值中,第k大的值是多少.区间大小为1的不计. ans设答案为ans,则$ans\\in [2,n]$.设函数$f[mid]$为值$\\le mid$的a有多少个,题目要求$f(ans)&gt;=K$且$ans$最大.然而这个函数是单调不增的.所以我们通过二分答案来找到ans. 关键是怎么求f的值. 小总结 T3problem[NOIP2011]聪明的质检员 ans可以发现w越大,y越小.此时$y=f(w)$是一个单调不上升函数.因此我们用二分法求出函数的零点即可. T4problem[NOIP2015]跳石头 ans二分跳跃距离,然后扫一遍如果两块石头之间的距离小于mid的话就移走一块.最后比较移走石头的数与m的大小. T5problem对于一个字符串,询问q次,每次询问$[l,r]$内最长回文串的长度.$n,q\\le 1e5$. ans T6problem一个$n\\times m$的网格图,其中有的格子有障碍,有的没有.有T个询问,每次询问一个子矩阵,查询该子矩阵内边长最大的没有障碍的正方形的边长 ans二维ST表(跪). 扩展:$\\Theta(1)LCA$如图,如果我们想要求出6和5的LCA,我们可以看到在深度序中2和5中间深度最小的是2,所以LCA是2.这个过程需要一次DFS和一个ST表.","categories":[{"name":"课堂笔记","slug":"课堂笔记","permalink":"http://yoursite.com/categories/课堂笔记/"}],"tags":[{"name":"倍增","slug":"倍增","permalink":"http://yoursite.com/tags/倍增/"}],"author":"i-cookie"},{"title":"10月2日贪心","slug":"贪心10.2","date":"2019-10-02T03:12:33.000Z","updated":"2019-10-09T06:30:34.000Z","comments":true,"path":"2019/10/02/贪心10.2/","link":"","permalink":"http://yoursite.com/2019/10/02/贪心10.2/","excerpt":"","text":"T1problem要堆一个雪人需要三个不同大小的雪球.现在有n个给定大小的雪球,问能堆起多少个雪人. ans数量最多的球先用.比如$100,1,1,1,1$.如果先取$1,1,1$,就只能堆一个,但是如果用了$100$中的一个,就可以堆两个.多的一定先用.所以只要统计+排序就可以了. T2problem超市打折.如果购物车里最少有一个凳子,则可以半价购买购物车里最便宜的物品.现在你要购买n个物品,其中一些是凳子.你有k个购物车,求一个最优的购物方案使得花费最少. ans凳子的最大优惠只能是优惠他自己.因为假设一个购物车中凳子不是最贵的,那么只能优惠凳子.如果凳子是最贵的,结果只会更劣.所以把前$k-1$贵的凳子放进前$k-1$个购物车,剩下的全部装在一个购物车里. T3problem有n个罗汉,每个罗汉有重量w和力量s定义一个罗汉的危险值为上面所有物品的重量值和减去他的力量.安排一个顺序使得危险值最大的罗汉危险值最小. ans考虑邻项交换法得到一个结论.按照$w_i+s_i$从小到大的顺序排序结果最优. T3problem[JSOI2007]基地里有n个建筑收到了严重的损伤,但只有一个维修工人.修复一个建筑需要$t_i$的时间,工人一次只能修一个,如果某个建筑在$b_i$时间里没有修好,它就报废了.要求制定一个合理的顺序,来抢修更多建筑. ans先按照d从小到大排序,中途对决策做更改.遍历所有建筑i,如果能修就修. 如果不能,那么在先前修复的建筑中找到耗时最大的建筑,时光倒流,如果那个建筑的耗时比这个长,那就放弃那个,改修这个.相当于修同样多的建筑,使用的总时间最短.时光倒流可以通过大根堆实现. T4problem[GDOI2018 D1T2]给定a[1…n],a_i\\in [0,m-1],每次操作可以在%m意义下对任意一个区间[l,r]整体+1或者-1,求最少几次操作可以使得所有数字变成0. ans对a维护一个差分数组,我们的目标是把差分数组变成全0.区间加减变成了端点加减.一个正数对应一个负数.如果正数之和为A,负数之和为B,那么结果就是$max(A,|B|)$. T5problem给定一个最大240位的大整数S,去掉其中任意N个数字,使得剩下的数字组成一个新的正整数S’.对于给定的N和S,寻找一种方案使得剩下的数字组成的新数S’最小. ans从前往后扫,如果一直递增就删掉最后的数.如果出现递减就把拐点删掉然后从头开始再扫一遍. T6problem各处n个正整数,需要把他们连接成一排,组整一个最大的多位整数. ansT7problem给定一棵n个点的有根树,每个点x上有a[x]朵樱花,设fa[x]表示父亲,son[fa[x]]表示父亲的儿子数.现在可以删掉一些节点,然后被删掉节点的樱花会加给父亲,它的儿子也会接在父亲上.要求删完x之后,fa[x]的樱花数+fa[x]的儿子数&lt;M.问最多能删除多少个点. ans自底向上删除,每次删除儿子中a[x]+son[x]最小的一个,这样对自己的增量最小.自底向上删除更有利于实现.而且能删要尽量删除.因为对于一个点和它父亲,只能删除其中一个.如果删除了父亲,会导致爷爷的键值增加,而删除自己就不会,更有利于上层的点被删除. T8problem给出一个n点m边的有向图,且保证前n-1条边构成一个以1为根的dfs树.T-simple的定义是至多一条边不在这棵树上的环.问至少要选中多少条边使得每个T-simple都至少被选中一条边. ans因为这是一棵dfs数,所以图中除了树边就只有返祖边了. 先来看一个子问题,如果是一个序列要求若干区间都要被选中,那么就从前往后扫,在未选择区间的右端点选点即可.所以把问题转化到树上也是类似的. T9problem给出一个M个逆序对的数列,求出一个最小的,字典序大于原序列的,逆序对也为M的数列.N&lt;=5e6. ans","categories":[{"name":"课堂笔记","slug":"课堂笔记","permalink":"http://yoursite.com/categories/课堂笔记/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"}],"author":"i-cookie"},{"title":"矩阵乘法初步","slug":"矩阵乘法初步","date":"2019-10-01T11:42:20.000Z","updated":"2019-10-20T03:25:32.000Z","comments":true,"path":"2019/10/01/矩阵乘法初步/","link":"","permalink":"http://yoursite.com/2019/10/01/矩阵乘法初步/","excerpt":"","text":"矩阵运算是一类特殊而且有意思的运算方式,有的特殊矩阵甚至可以视为向量这次我们来介绍一下矩阵加法和乘法. 基本内容矩阵加法:只有规格相同的矩阵才能相加,相加的结果仍然是规格相同的矩阵,矩阵中的元素为两个矩阵中对应元素相加,并不难理解,于是不再多说. 重点是矩阵乘法 矩阵乘法的适用同样有条件,只能是$m\\times n$和$n\\times r(n,m,r\\in N^*)$.在这里我决定先给出公式再解释. $$C_{i,j}=\\sum_{k=1}^{n}A_{i,k}\\times B_{k,j}$$ 这就是新矩阵的每一位元素的得出方法.接下来我来介绍我们是怎么定义这种计算的.矩阵乘法的第i行第j个元素就是第一个矩阵第i行所有元素分别乘上第二个矩阵第j列所有元素的值.我们之所以规定必须是$m\\times n$和$n\\times r$的矩阵相乘.是为了保证了第i行和第j列都有n个元素,能够一一对应才如此. 矩阵乘法有什么性质呢首先也是最容易忽略的一条,它不满足交换律.从定义我们可以看出,在左边的矩阵提供提供行,右边的矩阵提供列.因此交换左右可能乘法甚至失去意义.不过它满足结合律.同时也满足左右分配律. 矩阵乘法有什么用呢?它可以用来加速递推,最简单也是最经典的例子,它可以在$\\Theta(log_2n)$的时间复杂度内求出斐波那契数列的第n项,现在我们来看一看这个例子.我们知道,斐波那契数列的递推公式是这样的:$$ fib_i=\\begin{cases}&amp;1&amp; &amp;{i=0,1}\\\\&amp;fib_{i-1}+fib(i-2)&amp; &amp;{i\\le 2}\\\\\\end{cases}$$前两位已经固定了,因此我们来研究后面的怎么办.我们可以构建一个矩阵$\\begin{bmatrix}fib_{i-1}\\\\fib_{i-2}\\end{bmatrix}$,把它们装在矩阵里之后,我们的目标就是得到$\\begin{bmatrix}fib_{i}\\\\fib_{i-1}\\end{bmatrix}$我们可以尝试左乘或者右乘一个矩阵试试.我们发现,如果尝试右乘,将要乘一个$1\\times 1$的矩阵,最后没法推出,除非我们把矩阵”横过来”.而左乘一个矩阵则可以.考虑我们要得到新矩阵,它的第一个元素是旧矩阵两个元素之和,第二个元素只是旧矩阵第一个元素.通过思考,我们可以构造出以下式子:$$\\begin{bmatrix}1&amp; 1\\\\1&amp; 0\\end{bmatrix}\\times\\begin{bmatrix}fib_{i-1}\\\\fib_{i-2}\\end{bmatrix}=\\begin{bmatrix}fib_{i}\\\\fib{i-1}\\end{bmatrix}$$然而这只是实现了递推,为了超快求出第n项,我们还有一种神奇的方法:快速幂. 矩阵的快速幂是实现加速的核心.因为我们是通过乘以同一个矩阵多次才求出结果,因次可以通过将转移矩阵自身自乘多次来达到$\\Theta(log_2n)$的复杂度.接下来上代码(快速求$fib_{n}\\ mod\\ 1e9+7(n\\le Max_longlong)$) #include &lt;cmath&gt; #include &lt;queue&gt; #include &lt;deque&gt; #include &lt;cctype&gt; #include &lt;string&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #define int long long #define mod 1000000007 using namespace std; template&lt;class T&gt; inline void read(T &amp;x) { x = 0; char ch = getchar(), w = 0; while (!isdigit(ch)) w = (ch ==&#39;-&#39;), ch = getchar(); while (isdigit(ch)) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); x = w ? -x : x; return; } int n, org[3] = {0, 1, 1}; struct matrix { int a[3][3]; matrix() { memset(a, 0, sizeof(a)); } matrix operator * (const matrix &amp;b) const { matrix res; for (int i = 1; i &lt;= 2; ++i) for (int j = 1; j &lt;= 2; ++j) for (int k = 1; k &lt;= 2; ++k) res.a[i][j] = (res.a[i][j] + a[i][k] * b.a[k][j]) % mod; return res; } }; matrix ans, base; inline void quick_multrix(int times) { while (times) { if (times &amp; 1) ans = ans * base; base = base * base; times &gt;&gt;= 1; } return; } signed main() { read(n); if (n &lt;= 2) { cout &lt;&lt; 1 &lt;&lt; endl; return 0; } base.a[1][1] = base.a[1][2] = base.a[2][1] = 1; ans.a[1][1] = ans.a[1][2] = 1; quick_multrix(n - 2); cout &lt;&lt; ans.a[1][1] % mod &lt;&lt; endl; return 0; }","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://yoursite.com/categories/经验总结/"}],"tags":[{"name":"数论,数学","slug":"数论-数学","permalink":"http://yoursite.com/tags/数论-数学/"},{"name":"矩阵运算","slug":"矩阵运算","permalink":"http://yoursite.com/tags/矩阵运算/"}],"author":"i-cookie"},{"title":"10.1 模拟赛","slug":"10.1模拟赛","date":"2019-10-01T06:16:54.000Z","updated":"2019-10-09T06:28:00.000Z","comments":true,"path":"2019/10/01/10.1模拟赛/","link":"","permalink":"http://yoursite.com/2019/10/01/10.1模拟赛/","excerpt":"","text":"T1给出一个斐波那契数列,定义$F_n=\\sum_{i=0}^{n}f[i]$,要求出$F_i$的前n项和. ans我:乘法分配律+前缀和!$70-&gt;20$ 知道为什么吗?因为前缀和不取模是世界上最**的错误$dalao$: T2给定一棵无根树和一些路径,问在所有的根的选择和树链剖分的方式中,这些路径最少覆盖多少次轻边.我:枚举根+$LCA$+树上差分!$-&gt;45pts$.问题就处在枚举根上. 换根法,之后再学. T3放弃(蒟蒻大哭)","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"递推","slug":"递推","permalink":"http://yoursite.com/tags/递推/"},{"name":"树形结构","slug":"树形结构","permalink":"http://yoursite.com/tags/树形结构/"}],"author":"i-cookie"},{"title":"字符串/序列类DP(四)","slug":"字符串DP4","date":"2019-09-30T16:00:00.000Z","updated":"2019-10-11T11:26:50.000Z","comments":true,"path":"2019/10/01/字符串DP4/","link":"","permalink":"http://yoursite.com/2019/10/01/字符串DP4/","excerpt":"","text":"$\\text{蒟蒻在DP之路上求索着}$ 题面:P2401 不等数列平时在写DP的时候不能看到题目就开始想状态.应该先看题目能不能提取出什么有利于解决的信息或者能不能转化成更简单的问题.还有很重要的一点是,可以不从头考虑问题,而是假设前面已经推出了答案,然后考虑下一步.在这个题目中,我们比较容易找到子问题,设$f[i][j]$表示在一个$1…i$的排列中有恰好有$j$个小于号的时候的个数.那么如果我们现在已经推出了$i-1$个数的答案,现在考虑把第i个数排在哪里. 放在序列最左边,大于号++,小于号不变 放在序列最右边,小于号不变,小于号++ 插入左边小右边大(也就是原本一个小于号)的位置,大于号++,小于号不变 插入左边大右边小(也就是原本一个大于号)的位置,大于号不变,小于号++ 由以上规律我们可以发现,如果我们得到了$f[i][j]$,我们通过它能更新$f[i+1][j]$和$f[i+1][j+1]$(因为小于号要么不变要么变多).其中有$j+1$个位置可以使小于号不变,有$i-j$个位置可以使小于号增加.所以我们得出了以下的转移方程:$$f[i+1][j]=(j+1)\\times f[i][j]\\f[i+1][j+1]=(i-j)\\times f[i][j]$$初始化$f[1][0]=1$,这个问题就解决了","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"}],"author":"i-cookie"},{"title":"字符串/序列类DP(二)","slug":"字符串DP2","date":"2019-09-29T04:03:51.000Z","updated":"2019-10-09T06:26:14.000Z","comments":true,"path":"2019/09/29/字符串DP2/","link":"","permalink":"http://yoursite.com/2019/09/29/字符串DP2/","excerpt":"","text":"题目:P1026 统计单词个数 $\\text{蒟蒻在DP之路上求索着}$ 作为一道NOIP的中档题目,它很好地把我虐趴下了展现出了NOIP的难度水平.以至于不看题解我根本没思路花了好久好久才A掉. 思路这道题让我学习了如何使用$STL$中的$string$.它真是太好用了.$string$中有一个$find(str)$函数,可以用于从字符串中找到$str$第一次出现的首字母下标.这为字符串的匹配提供了极大的便利.题目中还有一个要求就是分块.而$string$中恰好有一个叫做$substr(ind,length)$,可以用来从第$ind$位开始提取出长度为$length$的字符串.因此这道题简直是为$string$量身定制的. 接下来我们来看题目.在得到这个字符串之后,题目要求我们分块并分别统计单词个数.那么我们就要想了:分块的方法千千万,有没有什么方法使得我们能直接求出单词个数呢?如果没有,我们有没有办法储存区间的单词个数来节约时间呢?显然,直接求出单词个数是不现实的.那我们考虑怎么预处理.因为分块的不确定性很大,一块的长度可能很长,也可能很短.因此我们不得不统计$tot[l][r](1\\le l\\le r\\le L)$.这是一个长度平方级别的预处理,完全可以承受的住.但是我们怎么处理呢? 题目中有一个要求,说我们在选择一个单词以后它的首字母就不能再次作为另一个单词的一部分了.换句话说,对于一个新字母来说,如果它是一个单词的首字母,那么这个区间中最多多加一个单词.就像是01背包,这个字母只能取一次.因此怎样让它只取一次呢?倒序!01背包就是这么做的.我们从后往前枚举位置,当往前扩展到一个新字母的时候,我们看看有没有区间中能不能形成一个新的单词.如果有,这个区间的$tot$就加上1,注意,只加1.通过这种方式,我们就可以预处理出任何一个区间内的单词个数了. 接下来就是DP的过程了.类似于在序列中插入一些东西,我们可以设$f[i][j]$表示把前i个字母分成j组的答案.这也是整个问题的子问题.接下来我们怎么转移呢?我们来”时光倒流”一下.之前我们可能已经形成了若干组,那么这一个字母到底属于那一组呢?有两种可能,一种是自成一组,要么是和之前归为一组,而和之前的归为一组又要考虑之前一组有多少字母.我们可以通过枚举之前最后一组和倒数第二组的分界线来确定.总而言之,我们将会得到以下方程$$f[i][j]=max(f[i][j], f[k][j]+tot[k+1][i])(j\\le k&lt;i)$$k就是我们的断点. 通过这道题我们可以注意到string的好用字符串问题和区间DP有时会有异曲同工之处(其实这道题就是区间DP).一定要按照DP的思路,一步一步地解题,而不是面对一团乱麻叹气. #include &lt;cmath&gt; #include &lt;queue&gt; #include &lt;deque&gt; #include &lt;cctype&gt; #include &lt;string&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; template&lt;class T&gt; inline void read(T &amp;x) { x = 0; char ch = getchar(), w = 0; while (!isdigit(ch)) w = (ch ==&#39;-&#39;), ch = getchar(); while (isdigit(ch)) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); x = w ? -x : x; return; } int n, m, s, tot[300][300], f[300][300]; string org, word[10]; int main() { read(n), read(m); org += &quot;0&quot;; for (int i = 1; i &lt;= n; ++i) { string a; cin &gt;&gt; a, org += a; } read(s); for (int i = 1; i &lt;= s; ++i) cin &gt;&gt; word[i]; int L = org.length() - 1; for (int i = L; i &gt;= 1; --i) { for (int j = i; j &gt;= 1; --j) { tot[j][i] = tot[j + 1][i]; string a = org.substr(j, i - j + 1); for (int k = 1; k &lt;= s; ++k) if (a.find(word[k]) == 0) { tot[j][i]++; break; } } } for (int i = 1; i &lt;= L; ++i) f[i][i] = f[i - 1][i - 1] + tot[i][i]; for (int i = 1; i &lt;= L; ++i) f[i][1] = tot[1][i]; for (int i = 1; i &lt;= L; ++i) { for (int j = 1; j &lt;= m &amp;&amp; j &lt;= i; ++j) { for (int k = j; k &lt; i; ++k) { f[i][j] = max(f[i][j], f[k][j - 1] + tot[k + 1][i]); } } } cout &lt;&lt; f[L][m] &lt;&lt; endl; return 0; }","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://yoursite.com/categories/经验总结/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"}],"author":"i-cookie"},{"title":"贪心与背包——P1987摇钱树","slug":"贪心+背包","date":"2019-09-27T05:07:46.000Z","updated":"2019-10-09T06:24:54.000Z","comments":true,"path":"2019/09/27/贪心+背包/","link":"","permalink":"http://yoursite.com/2019/09/27/贪心+背包/","excerpt":"","text":"题目：P1987 摇钱树 $\\text{蒟蒻在DP之路上求索着}$ 这道题我一开始竟然觉得是区间DP 思路看起来这道题我们可以以任何顺序来砍树,这就牵扯到先后砍树哪一种更优.如果我们要暴力的话,那就是枚举树的全排列,然后寻找最优解.可是如果我们不枚举,有没有办法通过一些方法判断出哪一棵树先砍呢? 还记得国王游戏吗,在那一题中我们讨论了邻项交换法来寻找贪心策略.我们不妨来尝试一下. 假设一棵树上的总钱数是$A$,每天掉落$a$个,另一棵树是$B$和$b$.我们先按照$A,B$的顺序在时间$x$和$x+1$砍掉.这时我们将会得到的收益为$A-ax+B-b(x+1)[1]$.而我们交换$AB$,得到的收益是$A-a(x+1)+B-bx[2]$,如果先砍$A$更优,那么我们要求$[1]$式-$[2]$式要大于0.经过整理,我们发现此时$a-b&gt;0$,也就是$a&gt;b$.现在我们可以得出结论了:先砍倒掉钱速度快的树更划算.因此我们要按照掉落速度从大到小排序. 但是我们只能砍掉K棵树,也就是说我们上文提到的$B$不一定能砍掉,然而我们的交换是在两棵树都能砍掉的前提下进行的,因此要有所取舍.这就是一个容量是K的01背包问题.设$f[j]$表示砍掉$i$棵树的最大值,那么我们不难得出:$$f[j]=max(f[j],f[j-1]+max(0,A[i]-a[i]\\times (j-1)))(1\\le i\\le n,1\\le j\\le max(i,K))$$这样问题就解决了.因此贪心和DP有时也能有很好的结合.当然了: $\\textit{多测不清空,爆零两行泪}$","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"背包","slug":"背包","permalink":"http://yoursite.com/tags/背包/"}],"author":"i-cookie"},{"title":"字符串/序列类DP（一）","slug":"字符串DP1","date":"2019-09-25T03:52:11.000Z","updated":"2019-10-09T06:23:26.000Z","comments":true,"path":"2019/09/25/字符串DP1/","link":"","permalink":"http://yoursite.com/2019/09/25/字符串DP1/","excerpt":"","text":"题目:P1279 字串距离 $\\text{蒟蒻在DP之路上求索着}$ 这道题让我想起了在一个数字串中添加若干乘号使得乘积最大的问题。我开始考虑在前$i$个字符中插入$j$个字符的最小距离。后来我发现我不会转移（泪）。于是我打算一步一步，从分析开始找到其中的秘密。 思路观察这道题是要求字符匹配然后求出最小的差值。因此相比于在字符串中插入空格，不如说是指定哪个字符与哪个字符配对，使得距离最小。于是我又联想到了P1140 相似基因，如果我们设$f[i][j]$表示A串中的前i个字符和B串中的前j个字符进行决策所能带来的最小距离,会不会能够更简单呢? 然后根据通常DP的思路,我们应该考虑它的子问题.也就是假设我们前面已经求出了最小距离,接下来应该怎么办呢?在这个题目中我们有三种决策: 让$A_i$与$B_j$配对 让$A_i$与空格配对,把$B_i$留在后面 让$B_i$与空格配对,把$A_i$留在后面 我们找到了这三种决策,然后我们考虑能否转移,怎样转移. 如果我们让$A_i$与$B_j$配对,那么就是从$f[i-1][j-1]$转移过来,然后加上这两位差的绝对值. 如果我们让$A_i$与空格配对,那么就是要求$B_j$已经和A中之前的字符或空格配对了,这样才能保证前i位对应前j位,然后加上常数K 同理,如果让$B_i$与空格配对,就要求$A_i$与B中之前的东西配对,然后加上常数K. 这样看来,我们转移到$f[i][j]$时,需要从以下三个决策中取得最小值:$$1.f[i-1][j-1]+|A[i]-B[j]|(\\text{两串配对})$$$$2.f[i-1][j]+K(\\text{A与空格配对})$$$$3.f[i][j-1]+K(\\text{B与空格配对})$$然后还有一点就是我们显然是需要初始化的,不能什么都不匹配.所以我们让两串分别先配对空格.最后我们的目标是$f[lenth(A)][length(B)]$ 类似的问题还有很多,以后再继续讲解","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://yoursite.com/categories/经验总结/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"}],"author":"i-cookie"},{"title":"区间dp与滚动数组——[USACO10DEC]宝箱Treasure Chest","slug":"区间DP滚动数组","date":"2019-09-21T14:24:28.000Z","updated":"2019-10-09T06:21:50.000Z","comments":true,"path":"2019/09/21/区间DP滚动数组/","link":"","permalink":"http://yoursite.com/2019/09/21/区间DP滚动数组/","excerpt":"","text":"题目:P3004 [USACO10DEC]宝箱Treasure Chest $\\textit{蒟蒻在DP之路上求索着}$ 这道题要求每次只能从最左边或者最右边取走硬币,这是一个经典的区间DP模型. 思路在刚刚看到这个题目的时候,我首先像个傻子一样想到了”哪边大拿哪边不就好了”.但是只需要三秒钟就可以找到一个反例:$$1,2,114514,3$$别忘了,对手也会取最优策略. 也就是说,我们的行动不只可以为了眼前拿到最大的,也可以是为了逼迫对手能走出对自己有好处的一步.这种长远打算的题目,怎么能离得开DP呢.一个比较初步的想法:我们可以设$f[i][j]$表示两人取走从$i$到$j$的一段,先手能得到的最大收益区间DP中常用的思想就是考虑最后一步,或者说最短的区间是怎样做的,然后递推到更长的区间.那我们就想象”时光倒流”的过程.接下来我们考虑怎么转移. 当我们添加新的一步的时候,无非就是两种情况:在左边加或者在右边加.我们最终要取走这个区间所有的硬币,因此我们让对手取走的最少,剩下的自然就都是自己的了.我们怎么表示对手取得了多少呢?事实上并不用专门去表示.当我们设$f[i][j]$表示拿走$i$到$j$这一段,先手能得到的最大价值的时候,就已经不分敌我了.这个区间谁先手只由区间长度取决,我们不必关心.因为最后求出整个区间的先手最大值一定是自己的(题目要求自己先手嘛). 那么我们现在处于区间$[l,r]$,该怎么转移呢?就像我说的,两个人取走的和必然是$sum[l,r]$.因此从当前先手的角度考虑,$sum[l,r]-min(f[l+1][r],f[l][r-1])$,也就是区间和减去对手的最小值就是我的最大值.区间长度只减少1的话,之前的先手肯定是对手,他会采取最优策略,因此我们就由之前已经推出的$f$数组就可以了.也就是说:$$f[l][r]=sum[l][r]-min(f[l+1][r],f[l][r-1])$$$sum$数组可以用前缀和快速求出因此我们写出了这道题的方程 然后就爆空间了这是非常悲哀的.因为空间限制只有64M.这就要求我们对空间的优化.这就要提到我们的滚动数组了.因为我们只需要用到之前一个长度的区间,而且相同长度的区间我们只取一个最优解,因此之前的都可以舍去了.那么这是怎么做到的呢?我们之前枚举左右端点相当于枚举长度.那么我们直接一维枚举长度,然后一维枚举左端点,不就可以直接转移到这个区间了吗?具体来说,我们设$f[i]$表示左端点为$i$的区间中先手能取得的最大值.我们的最终目标是$f[1]$.那么转移方程就是:$$f[i]=sum[i+L-1]-sum[i-1]-min(f[i],f[i+1]),1\\le L\\le n$$注意到,我们的$min$中是$f[i]和f[i+1]$,这就是滚动数组高效利用空间的体现.在转移之前,$f[i]$就是以$i$为左端点,长度为$L-1$的最大值,$f[i+1]$就是以$i+1$为左端点,长度为$L-1$的最大值.这两个值恰好代表了之前的$f[l][r-1]$和$f[l+1][r]$. 代码: #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; int n, a[5005], f[5005]; inline int min(int x, int y) { return x &lt; y ? x : y; } int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; f[i] = a[i];//不难理解的初始化 a[i] += a[i - 1];//省略前缀和数组 } for (int l = 2; l &lt;= n; l++)//一定要由短区间转移到长区间,因此外层枚举长度 for (int i = 1; i + l - 1&lt;= n; i++)//枚举左端点 f[i] = a[i + l - 1] - a[i - 1] - min(f[i], f[i + 1]); cout &lt;&lt; f[1] &lt;&lt; endl; return 0; } 滚动数组的另一个重要且典型的应用在01背包中,这里就不再赘述.","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"区间DP","slug":"区间DP","permalink":"http://yoursite.com/tags/区间DP/"}],"author":"i-cookie"},{"title":"多重背包的二进制分解法","slug":"多重背包","date":"2019-09-20T03:57:06.000Z","updated":"2019-10-09T06:20:18.000Z","comments":true,"path":"2019/09/20/多重背包/","link":"","permalink":"http://yoursite.com/2019/09/20/多重背包/","excerpt":"","text":"$\\text{蒟蒻在DP之路上求索着}$ 羞羞脸打广告来获得更好的阅读体验 这是一道裸的多重背包,也就是给出若干种物品,每种物品的价格是$v_i$,每种物品的代价是$w_i$,每种物品有$c_i$件的背包问题. 思路当我们在看到这种题的时候,首先想到可以直接把每种物品视为$c_i$件不同的物品,然后做01背包.这原则上是正确的.但是,题目显然不会这么放你$AC$.数据范围往往会让你的01背包TLE. 这样来看,当我们把需要做的事完全拆分碎,就造成了大量时间的花费.那么我们可以联想到我们曾重点讨论的倍增的思想. 在这道题中,我们不必把很多件物品拆分成一个一个的单件物品,而可以通过二进制的方法,使得不管你打算取其中的多少件,都可以表示的出来.也就是通过将同种物品分组,使得选择其中不同的组合能够等价于选择各种数量的单件.具体操作是这样的: 我们将$c_i$二进制分解,但是要求每一位二进制位都必须是1.这显然是无法适应所有数据的.毕竟不是所有数据都满足$c_i=2^k-1$.即便如此我们也要尽量做到这一点.因此我们要找到最大的$k$,使得$t=\\sum_{i=0}^{k}2^i$满足$t\\le c_i$.也就是找到最大的,小于$c_i$的二的各个次幂和.到目前为止我们可以通过不重复且有选择地使用$2^0$到$2^k$来表示出$1$到$t$所有的数.但是剩下的咋办呢?我们将剩下的$c_i-t$单独分为一组.因为$1$到$t$都可以表示,那么有了这个$c_i-t$组就可以表示出所有数了.例如我们会把21分为$1,2,4,8,6$,这样就可以从中不重复地选择来表示出$1$到$c_i$的所有数了. 这时候,问题已然变成了一个01背包问题.时空间复杂度均得到了优化. 题解代码: #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; int n, v, p[10005], w[10005], f[40005]; int main() {//f数组为常规01背包数组, cin &gt;&gt; n &gt;&gt; v;//w是重量数组 int tot = 0;//p是价值数组,tot是物品数量 for (int i = 1; i &lt;= n; i++) {//二进制拆分 int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; for (int j = 1; j &lt;= c; j &lt;&lt;= 1) { p[++tot] = j * a;//循环2的0到k次方 w[tot] = j * b;//每件物品相当于若干 c -= j;//单件的捆绑 } if (c &gt; 0) {//此时c只剩下没分解的部分了 p[++tot] = c * a; w[tot] = c * b; } } for (int i = 1; i &lt;= tot; i++)//平凡的01背包 for (int j = v; j &gt;= w[i]; j--) f[j] = max(f[j], f[j - w[i]] + p[i]); cout &lt;&lt; f[v] &lt;&lt; endl; return 0; }","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://yoursite.com/categories/经验总结/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"背包","slug":"背包","permalink":"http://yoursite.com/tags/背包/"}],"author":"i-cookie"},{"title":"二维差分与二维前缀和","slug":"二维差分和前缀和","date":"2019-09-13T13:17:17.000Z","updated":"2022-05-23T04:47:37.754Z","comments":true,"path":"2019/09/13/二维差分和前缀和/","link":"","permalink":"http://yoursite.com/2019/09/13/二维差分和前缀和/","excerpt":"","text":"推荐模板题:[USACO19FEB]Painting The Barn差分与前缀和互为逆运算,即差分数组的前缀和数组为原数组,前缀和数组的差分数组为原数组.二者都利用了容斥原理,这一点在二维平面(或者二维数组)中体现的更加明显. 那么我们先来讲二维前缀和 二维前缀和一维的前缀和数组是求从数组的首项加到当前项的和,即:$$sum[i]=\\sum_{j=1}^{i}a[j]=(\\sum_{j=1}^{i-1}a[j])+a[i]=sum[i-1]+a[i]$$这就是一维前缀和的递推方法.那么二维的前缀和,我们定义为以二维数组的首行首列(即左上角)元素为左上角,当前位置元素为右下角的矩阵的元素和.当我们推到$(i,j)$时,我们考虑该怎么计算$sum[i][j]$.由于左上角已经固定,我们只考虑右下角.当右下角为$(i,j-1)$时,这是一个$(i,j)$左侧的矩阵,当右下角为$(i-1,j)$时,这表示一个$(i,j)$上方的矩阵.那么如果我们要求$(i,j)$左上方所有元素的和,是不是只要将这两个已经计算好的矩阵和加起来,再加上$a[i][j]$就行了呢? 当然不是. 因为左侧的矩阵和上方的矩阵有一个重合部分,即一个以$(i-1,j-1)$为右下角的,完全位于$(i,j)$左上方的矩阵,直接相加时它被计算了两次,因此我们要把它减去.即:$$sum[i][j]=sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1]+a[i][j]$$ 么这就是二维前缀和,求某个矩阵的和的时候过程与此类似. 二维差分一维的差分是指每一项比前一项多多少,即:$$cf[i]=a[i]-a[i-1]$$通过差分数组和树状数组可以实现快速的区间加减,也就是使$cf[l]+v,cf[r+1]-v$(注意$r$要$+1$).当我们要求回复正常形式的数组的时候,只需要求前缀和就可以了,即:$$a[i]=cf_sum[i-1]+cf[i]$$那么二维差分呢?它只不过是在一维差分上又加了一维而已.它的递推公式是这样的:$$cf[i][j] = a[i][j]-a[i][j-1]-a[i-1][j]+a[i-1][j-1]$$即当前元素减去左边元素再减去上边元素再加上左上角元素. 那么由二维差分数组要求出原数,只需要求出二维前缀和即可.通过二维差分可以快速实现矩阵加减.","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://yoursite.com/categories/经验总结/"}],"tags":[{"name":"递推","slug":"递推","permalink":"http://yoursite.com/tags/递推/"}],"author":"i-cookie"},{"title":"luogu P1854 花店橱窗设置","slug":"花店橱窗设置","date":"2019-09-10T05:12:58.000Z","updated":"2019-10-09T06:17:38.000Z","comments":true,"path":"2019/09/10/花店橱窗设置/","link":"","permalink":"http://yoursite.com/2019/09/10/花店橱窗设置/","excerpt":"","text":"DP怎么能学好呢(允悲题目描述 某花店现有$F$束花，每一束花的品种都不一样，同时至少有同样数量的花瓶，被按顺序摆成一行，花瓶的位置是固定的，从左到右按$1$到$V$顺序编号，$V$是花瓶的数目。花束可以移动，并且每束花用$1$到$F$的整数标识。如果$I &lt; J$，则花束$I$必须放在花束$J$左边的花瓶中。例如，假设杜鹃花的标识数为$1$，秋海棠的标识数为$2$，康乃馨的标识数为$3$，所有花束在放入花瓶时必须保持其标识数的顺序，即杜鹃花必须放在秋海棠左边的花瓶中，秋海棠必须放在康乃馨左边的花瓶中。如果花瓶的数目大于花束的数目，则多余的花瓶必须空，即每个花瓶只能放一束花。 每个花瓶的形状和颜色也不相同，因此，当各个花瓶中放入不同的花束时，会产生不同的美学效果，并以美学值（一个整数）来表示，空置花瓶的美学值为$0$。在上述的例子中，花瓶与花束的不同搭配所具有的美学值，可以用如下的表格来表示： 花瓶$1$ 花瓶$2$ 花瓶$3$ 花瓶$4$ 花瓶$5$ 杜鹃花 $7\\ 23\\ -5\\ -24\\ 16$ 秋海棠 $5\\ 21\\ -4\\ 10\\ 23$ 康乃馨 $-21\\ 5\\ -4\\ -20\\ 20$ 根据表格，杜鹃花放在花瓶$2$中，会显得非常好看，但若放在花瓶$4$中，则显得很难看。 为了取得最佳的美学效果，必须在保持花束顺序的前提下，使花的摆放取得最大的美学值，如果具有最大美学值的摆放方式不止一种，则输出任何一种方案即可。 输入格式 输入文件的第一行是两个整数$F$和$V$，分别为花束数和花瓶数（$1≤F≤100$，$F≤V≤100$）。接下来是矩阵$A_{i,j}$,它有$I$行，每行$J$个整数，$A_{ij}$表示花束$I$摆放在花瓶$J$中的美学值。 输出格式 输出文件的第一行是一个整数，为最大的美学值；接下来$1$行$F$个数,第$J$个数代表第$J$束花放在了哪个瓶子里。 题解这道题类似于$P2066$机器分配,不同的是这里每一朵花都是有编号的,而且必须按顺序放,这就意味着第$I$朵花只能放在第$I$到第$V$个瓶子里,因为前面的花都必须放好了才能放这一朵.我们有两种思路 思路一既然这道题类似于机器分配,那么我们是不是可以真的按照机器分配来做呢?设$f[i][j]$表示前$i$朵花放在前$j$个瓶子里的最大美学价值.接下来我们考虑子问题之间的转移. 在放第$i$朵花之前,我们要知道,第$i$朵花只能放在第$i-1$朵花的后面.因此我们要枚举第$i$朵花的可能的位置,就从$i$到$j$之间循环枚举.即:$$f[i][j] = max(f[i][j],f[i-1][k] + a[i][j]),i\\le k\\le j$$因为美学价值是可能是负的,所以我们需要将$f$数组初始化为$-inf$,然后$f[0][0]=0$. 思路二事实上还有一种方法来描述$f$数组,那就是设$f[i][j]$表示将第$i$朵花放在第$j$个花瓶中的最大美学价值.这时候,我们相当于硬点第$i$朵花放在第$j$个瓶子,因此我们枚举上一朵花的位置来转移.上一朵花可能放在区间$[i-1,j-1]$中.转移方程就是:$$f[i][j] = max(f[i][j],f[i-1][k])+a[i][j],i-1\\le k\\le j-1$$同样,我们需要初始化$f$数组为$-inf$,$f[0][0]=0$. 如何输出任意一组方案上述两种思路都使用类似的方法来输出方案,即倒着扫描,找到在最后一朵花时推出最优解的是哪一个瓶子,然后递归往前找倒数第二朵花时是哪一个瓶子推出了最终答案减去最后一个瓶子的美学价值,然后递归往前…最后在递归回来的时候输出. 代码: #include &lt;cmath&gt; #include &lt;queue&gt; #include &lt;deque&gt; #include &lt;cctype&gt; #include &lt;string&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #define int long long using namespace std; template&lt;class T&gt; inline void read(T &amp;x) { x = 0; char ch = getchar(), w = 0; while (!isdigit(ch)) w = (ch ==&#39;-&#39;), ch = getchar(); while (isdigit(ch)) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); x = w ? -x : x; return; } int n, m, f[105][105], a[105][105]; void print(int now, int nowans) { if (!now) return; int t = now; while (f[now][t] != nowans) t++; print(now - 1, nowans - a[now][t]); cout &lt;&lt; t &lt;&lt; &quot; &quot;; return; } signed main() { read(n), read(m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) read(a[i][j]); memset(f, 128, sizeof(f)); f[0][0] = 0; for (int i = 1; i &lt;= n; ++i) for (int j = i; j &lt;= m; ++j) for (int k = i - 1; k &lt;= j - 1; ++k) f[i][j] = max(f[i - 1][k] + a[i][j], f[i][j]); int ans = 0; for (int i = n; i &lt;= m; ++i) ans = max(ans, f[n][i]); cout &lt;&lt; ans &lt;&lt; endl; print(n, ans); return 0; }","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"TAG","slug":"TAG","permalink":"http://yoursite.com/tags/TAG/"}],"author":"i-cookie"},{"title":"luogu P3874 [TJOI2010]砍树","slug":"砍树","date":"2019-08-30T03:40:14.000Z","updated":"2019-10-09T06:16:22.000Z","comments":true,"path":"2019/08/30/砍树/","link":"","permalink":"http://yoursite.com/2019/08/30/砍树/","excerpt":"","text":"典型的树形DP,但是做起来还是要看题解,看来还是不会吖.题目背景 小$A$在果园里发现了一棵结满果子的树，于是他就打起了坏主意，他打算把树的一部分砍下来带回家。 题目描述 我们可以把这棵树表示成一个树型的结构，也就是说，任意两个点之间有且仅有一条路径。在每个点$i$处都结着一个水果，每个水果有一个价值$v_i$和重量$w_i$。小$A$想带走树的一部分（或全部），包含至少$K$个结点（也就是至少$K$个水果），且这些水果的平均价值尽可能高。平均价值是指水果总的价值除以总的重量。注意小$A$砍下的树必须是在原来的树中连通的一部分。 输入格式 第一行包含两个数$N$和$K$，分别表示树的结点数和小$A$至少应带走的水果数。第二行包含空格隔开的$N$个数，分别表示每个结点处水果的价值$v_i$。第三行包含空格隔开的$N$个数，分别表示每个水果的重量$w_i$。按下来$N-1$行，每行包含两个数$a_i$和$b_i$ （$1 ≤ a_i, b_i ≤ N$），表示在结点$a_i$和$b_i$之间有一条边。输入保证是一棵正确的树结构。 输出格式 输出一行，包含一个数，表示最大可能的平均价值。四舍五入到小数点后两位。 数据范围 对$100%$的数据，$1 ≤ N ≤ 100, 1 ≤ K ≤ N, 1 ≤ v_i ≤ 10000, 1 ≤ w_i ≤ 10000$ 解析看到价值和重量,就知道这是一道我不会的树上背包问题.一般背包可以设$f_{i}$表示选择重量不超过$j$的物品能获得的最大价值,但是这道题要结合树形结构,而且$w$和$v$的范围都很大,所以考虑基于个数来设置状态. 我们设$f_{i,j}$表示在以$i$为根的子树中选择$j$个点能获得的最大平均价值.对于它的每棵子树,我们枚举从中选择了多少节点来转移. ※因为题目要求记录平均值,而平均值并不容易直接转移,所以我们将$f$数组开成结构体,记录当前状态的总重量,总价值,以及平均值(总价值/总重量).这道题显然是树上$01$背包,因此别忘了要倒序循环外层. struct node { double w, v, ave;//重量,权值,平均值 node() {} node(double a, double b, double c) : w(a), v(b), ave(c) {} }f[105][105]; void dfs(int now, int father) { f[now][1] = node(w[now], v[now], v[now] / w[now]);//为了维护连通性,根节点肯定要选. for (int i = head[now]; i; i = nxt[i]) { if (to[i] == father)//枚举每个子节点 continue; dfs(to[i], now);//先递归下去,再由叶到根更新 for (int j = n; j &gt; 1; --j) {//枚举以now为根的子树中一共选择多少个点,注意01背包要倒序 for (int k = 1; k &lt;= j; ++k) {//枚举当前子树中选择了j个节点中的多少个 node p = f[to[i]][j - k];//在这个子树中选择了j个节点中的j-k个点 node q = f[now][k];//在其他子树中选择了k个点. double ave = (p.v + q.v) / (p.w + q.w);//计算平均值 if (ave &gt;= f[now][j].ave) {//更新答案 f[now][j] = node(p.w + q.w, p.v + q.v, ave); } } } } return; } 最后在所有$f[i][j](k \\le j \\le n)$中选择最大值输出即可. 感觉还是不会呢","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"树形结构","slug":"树形结构","permalink":"http://yoursite.com/tags/树形结构/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}],"author":"i-cookie"},{"title":"相邻项交换排序类贪心问题","slug":"邻项交换贪心","date":"2019-08-29T06:57:18.000Z","updated":"2019-10-09T06:14:40.000Z","comments":true,"path":"2019/08/29/邻项交换贪心/","link":"","permalink":"http://yoursite.com/2019/08/29/邻项交换贪心/","excerpt":"","text":"事实上这种考虑方式完全可以构成一类题的解题思路,因此我决定做一个小结,不过无法像ouuan奆佬那样写出完整的论文.重要参考:ouuan奆佬的博客浅谈邻项交换排序的应用以及需要注意的问题例题1 国王游戏题目描述 恰逢$H$国国庆，国王邀请$n$位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这$n$位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。 国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。 输入格式 第一行包含一个整数$n$，表示大臣的人数。 第二行包含两个整数$a$和$b$，之间用一个空格隔开，分别表示国王左手和右手上的整数。 接下来$n$行，每行包含两个整数$a$和$b$，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。 输出格式 一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。 解析此题是我见过的第一个邻项交换考虑最优性的题目,一句话来讲,对于一个大臣$i$,他的得分$c_i$这样定义:$$c_i=\\lfloor \\frac{\\prod_{j=1}^{i}l_j}{r_i}\\rfloor$$我们要最小化$c$的最大值.这时候我们考虑两个大臣$a,b$,如果$a$排在$b$的前面,就有$ans1=max(\\frac{L}{r_a},\\frac{L\\times l_a}{r_b})$,而如果$b$排在$a$前面,就有$ans2=max(\\frac{L}{r_b},\\frac{L\\times l_b}{r_a})$,其中$L$代表国王左手的数.我们假设不交换更优,即$ans1&lt;ans2$,那就意味着$max(\\frac{L}{r_a},\\frac{L\\times l_a}{r_b})&lt;max(\\frac{L}{r_b},\\frac{L\\times l_b}{r_a})$.为了表示简便,我们令$k1=\\frac{L}{r_a},k2=\\frac{L\\times l_a}{r_b},k3=\\frac{L}{r_b},k4=\\frac{L\\times l_b}{r_a}$,这时候我们发现一定有$k1&lt;k4,k2&gt;k3$,那么要想让$ans1&lt;ans2$成立,则只需要让$k4&gt;k2$,就可以保证$k4$是四个数中最大的了,写出来就是$$\\frac{L\\times l_b}{r_a}&gt;\\frac{L\\times l_a}{r_b}$$整理可得$l_ar_a &lt; l_br_b$.这就是我们排序的条件.","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://yoursite.com/categories/经验总结/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"}],"author":"i-cookie"},{"title":"luogu P1220 关路灯","slug":"关路灯","date":"2019-08-19T14:57:57.000Z","updated":"2019-10-09T06:13:34.000Z","comments":true,"path":"2019/08/19/关路灯/","link":"","permalink":"http://yoursite.com/2019/08/19/关路灯/","excerpt":"","text":"不看题解我是真的不会DP吖题目描述 某一村庄在一条路线上安装了$n$盏路灯，每盏灯的功率有大有小（即同一段时间内消耗的电量有多有少）。老张就住在这条路中间某一路灯旁，他有一项工作就是每天早上天亮时一盏一盏地关掉这些路灯。 为了给村里节省电费，老张记录下了每盏路灯的位置和功率，他每次关灯时也都是尽快地去关，但是老张不知道怎样去关灯才能够最节省电。他每天都是在天亮时首先关掉自己所处位置的路灯，然后可以向左也可以向右去关灯。开始他以为先算一下左边路灯的总功率再算一下右边路灯的总功率，然后选择先关掉功率大的一边，再回过头来关掉另一边的路灯，而事实并非如此，因为在关的过程中适当地调头有可能会更省一些。 现在已知老张走的速度为$1m/s$，每个路灯的位置（是一个整数，即距路线起点的距离，单位：$(m)$、功率$(W)$，老张关灯所用的时间很短而可以忽略不计。 请你为老张编一程序来安排关灯的顺序，使从老张开始关灯时刻算起所有灯消耗电最少（灯关掉后便不再消耗电了）。 输入格式 文件第一行是两个数字$n(1\\le n\\le 50$，表示路灯的总数$)$和$c(1\\le c\\le n$老张所处位置的路灯号$)$； 接下来n行，每行两个数据，表示第1盏到第n盏路灯的位置和功率。数据保证路灯位置单调递增。 输出格式 一个数据，即最少的功耗$($单位：$J$，$1J=1W·s)$。 解法其实我一上来连这题是区间DP都看不出来这题刚开始我认为应该设置$f_{i,j}$表示现在的时间点是$i$,坐标为$j$的最小答案.但是很快我就发现我太沙雕天真了,题目中并没有给出坐标的范围,而且这样做肯定很容易$MLE$,统计时的坐标也不重要,因为一次肯定从一个灯到另一个灯,显然不需要把所有坐标记下来.因此我打开题解一看,我们设$f_{i,j,0/1}$表示现在消掉了第$i$到第$j$盏灯,而且我们现在在$i$点$(0)$, 或者$j$点$(1)$的最小答案,目标:$min(f_{1,n,0},f_{1,n,1})$. 这样一看,这题还是很符合区间$DP$的特点的.因为我们消掉的一定是一个跨过起点的区间,因为假设有一个不跨过起点的区间,那么从起点到那个区间的路上,不顺便把路上的灯灭掉显然是不合算的.这样的话,我们枚举$i$的时候要从起点往前枚举,而枚举$j$的时候要从起点往后枚举,这样就可以保证区间跨过起点了.然后我们来考虑怎么转移. 比如我们现在在$f_{i,j,0}$,那么灭掉$i$这盏灯之前一定是灭掉了$[i+1,j]$,因此要从两种情况转移过来.一个是从i+1直接往左到i,另一个是从j回头往左到i.而此过程中其他灯都在运行,因此我们需要快速求出其他灯的总功率,乘以两点之间的距离.这可以通过一个前缀和数组来优化.也就是 $f[i][j][0]=min(f[i+1][j][0]+(sum[n]-sum[j]+sum[i])* dis(i,i+1),f[i + 1][j][1]+(sum[n]-sum[j]+sum[i])* dis(i,j))$其中$dis(i,j)$表示两点之间的距离(坐标相减).同理我们可以得到: $f[i][j][1]=min(f[i][j-1][0]+(sum[n]-sum[j-1]+sum[i-1])* dis(i,j),f[i][j-1][1]+(sum[n]-sum[j-1]+sum[i-1])* dis(j-1,j))$因为我们要取$min$,所以要初始化所有$f$为$inf$,然后$f[st][st]=0$就可以了. 代码: #include &lt;cmath&gt; #include &lt;queue&gt; #include &lt;deque&gt; #include &lt;cctype&gt; #include &lt;string&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; template&lt;class T&gt; inline void read(T &amp;x) { x = 0; char ch = getchar(), w = 0; while (!isdigit(ch)) w = (ch ==&#39;-&#39;), ch = getchar(); while (isdigit(ch)) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); x = w ? -x : x; return; } int n, st, f[100][100][2], sum[100]; struct node { int pos, pow; }light[100]; inline int dis(int l, int r) { return light[r].pos - light[l].pos; } int main() { read(n), read(st); for (int i = 1; i &lt;= n; ++i) read(light[i].pos), read(light[i].pow), sum[i] = sum[i - 1] + light[i].pow; memset(f, 0x3f, sizeof(f)); f[st][st][0] = f[st][st][1] = 0; f[st - 1][st][0] = (sum[n] - light[st].pow) * (light[st].pos - light[st - 1].pos); f[st][st + 1][1] = (sum[n] - light[st].pow) * (light[st + 1].pos - light[st].pos); f[st - 1][st][1] = f[st - 1][st][0] + (sum[n] - light[st].pow - light[st - 1].pow) * (light[st].pos - light[st - 1].pos); f[st][st + 1][0] = f[st][st + 1][1] + (sum[n] - light[st + 1].pow - light[st].pow) * (light[st + 1].pos - light[st].pos); for (int i = st; i &gt;= 1; --i) { for (int j = st; j &lt;= n; ++j) { if (i == st &amp;&amp; j == st) continue; f[i][j][0] = min(f[i + 1][j][0] + (sum[n] - sum[j] + sum[i]) * dis(i, i + 1), f[i + 1][j][1] + (sum[n] - sum[j] + sum[i]) * dis(i, j)); f[i][j][1] = min(f[i][j - 1][0] + (sum[n] - sum[j - 1] + sum[i - 1]) * dis(i, j), f[i][j - 1][1] + (sum[n] - sum[j - 1] + sum[i - 1]) * dis(j - 1, j)); } } cout &lt;&lt; min(f[1][n][0], f[1][n][1]) &lt;&lt; endl; return 0; }","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"区间DP","slug":"区间DP","permalink":"http://yoursite.com/tags/区间DP/"}],"author":"i-cookie"},{"title":"常见思想:倍增","slug":"倍增","date":"2019-08-17T08:38:14.000Z","updated":"2019-10-09T06:12:02.000Z","comments":true,"path":"2019/08/17/倍增/","link":"","permalink":"http://yoursite.com/2019/08/17/倍增/","excerpt":"","text":"倍增真的好难理解啊WSLNo.1 倍增RMQ:P3865 【模板】ST表题目描述 给定一个长度为$N$的数列，和$M$次询问，求出每一次询问的区间内数字的最大值。 输入格式 第一行包含两个整数$N,M$,分别表示数列的长度和询问的个数。 第二行包含$N$个整数$($记为 $a_i)$,依次表示数列的第$i$项。 接下来$M$行，每行包含两个整数$l_i,r_i$,表示查询的区间为 $[ l_i, r_i] $ $1≤N≤10^5,1≤M≤10^6,a_i∈[0,10^9],1≤l_i≤r_i≤N$ 输出格式 输出包含$M$行，每行一个整数，依次表示每一次询问的结果。 解法 线段树 emmmm,数据范围,请. ST表(重头戏) 倍增思想的重要应用,我们设$f[i][j]$表示从$i$开始,连续$2^j$个数中的最大(小)值.(我是真的难转过这个弯来,这样我们就可以发现一些事情: $f[i][0]=a[i]$(定义) $f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt;(j - 1))][j - 1])$ 第二条是因为什么呢? 首先我们要知道,$f$数组的处理顺序是先确定一个左端点,然后一直往右扩展$($固定$i$增加$j)$.因此每当我们把j+1,当前区间都会增长一倍,这时候区间$[i,j]$无非只有两种情况: 它在左半部分$([i,i+2^{j-1}])$ 它在右半部分$([i+2^{j-1},i+2^{j}])$ 这就是上式的意思啦.因为我们在处理$j$时,$j-1$的情况一定已经处理好了,所以可以做到递推. 代码: for (int j = 1; j &lt;= 20; ++j) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; j - 1)][j - 1]); 接下来就是询问了. 当我们在询问时,肯定不能保证区间长度恰好是$2$的次幂,也就是和$f[l][k]$不一定重合.因此我们将区间分成两个相交的部分,比如区间是$[l,r]$,那么我们就把区间分成两部分,但是这两部分是相交的:$[l,l+2^k],[r-2^k+1,r]$,其中$k$是最大的满足$2^k\\le$区间长度的正整数.这样取一下max就可以了. 但是我们注意到,k并不能用暴力来求,否则会当场去世.所以我们还要处理一个k的数组.我们注意到,我们需要$2^k\\le r-l+1$,这意味着,$k(k\\in N_+)$应该等于$\\lfloor log_2(r-l+1)\\rfloor$.我们需要处理一个$log_2$数组,(以及我们可以顺便初始化一下$f$数组). LOG[0] = -1; for (int i = 1; i &lt;= n; ++i) f[i][0] = a[i], LOG[i] = LOG[i &gt;&gt; 1] + 1; 学过对数函数的自然能看明白 现在我们可以放心大胆的求解了 代码: for (int i = 1; i &lt;= m; ++i) { read(q1), read(q2); int k = LOG[q2 - q1 + 1]; printf(&quot;%d\\n&quot;, max(f[q1][k], f[q2 - (1 &lt;&lt; k) + 1][k])); } No.2 倍增求LCA 序列和树链总是相通的——某位哲人 通常求$LCA$的方式有树剖,奇怪的我不会的神仙$O(1)$做法,以及本文要讲的倍增法. 一切都是从暴力开始的——某位哲人 当我们试图暴力求$LCA$的时候,画风将会是下面这个样子: inline int LCA(int x, int y) { while (x != y) { if (dep[x] &lt; dep[y]) swap(x, y); x = father[x]; } return x; } 数据范围大起来以后时间复杂度显然是$O($跑不过$)$,只能另想别的办法. 还记得上一道题吗?如果暴力在序列上找,同样会$TLE$,而这个暴力找$LCA$的过程也是一样的复杂度.因此我们可以尝试相似的优化方法.如果我们一次跳一大段,肯定能省很大的复杂度,甚至还可以让两个点一起跳. 我们这样来考虑: 为了保证相遇,我们通常令深度较大的一个点向上跳.倍增和暴力的最大区别是一次跳的步数和跳时两个点是否同步.仍然设$f[i][j]$表示从点$i$往上连续$2^j$的点.这次不再需要$LOG$数组,只要$f$数组就够了.当我们在寻找$x,y$的$LCA$时,先选中深度较大的一个点,然后不断往上跳,直到与另一个点深度相同.这是如何实现的呢?众所周知,任何正整数都可以进行二进制拆分,这和我们维护的第二维恰好很契合.根本上来说,我们就是把初始时两个点的深度的差$K$进行二进制拆分,在每个$”1”$位代表的数处跳一次.操作上来说,就是倒序循环$20$到$1$,如果跳一步后还比另一个点深,就跳.或者说是从$K$可能的最高位往下匹配,如果匹配到1就跳.不过为了防止在$”0”$的位置仍然得出”能跳”的结论从而导致最后无法恰好一样深,一定要倒序哦. 现在$x,y$一样深了,接下来,我们就在它们相遇之前,不断一起往上跳.同样是二进制思想.最终,他们之差一点就相遇了,这时候只需要随便选一个当代表往上跳一步就可以了,这就是$LCA$! 代码: int lca(int x, int y) { if (dep[x] &lt; dep[y]) swap(x, y); for (int i = 20; i &gt;= 0; i--) { if (dep[f[x][i]] &gt;= dep[y]) x = f[x][i]; if (x == y) return x; } for (int i = 20; i &gt;= 0; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; }","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://yoursite.com/categories/经验总结/"}],"tags":[{"name":"倍增","slug":"倍增","permalink":"http://yoursite.com/tags/倍增/"},{"name":"RMQ","slug":"RMQ","permalink":"http://yoursite.com/tags/RMQ/"},{"name":"LCA","slug":"LCA","permalink":"http://yoursite.com/tags/LCA/"}],"author":"i-cookie"},{"title":"神奇思想:离线操作","slug":"离线操作","date":"2019-08-14T10:16:20.000Z","updated":"2019-10-09T06:10:10.000Z","comments":true,"path":"2019/08/14/离线操作/","link":"","permalink":"http://yoursite.com/2019/08/14/离线操作/","excerpt":"","text":"本文不讨论强制在线(允悲)有一些看起来很不可做的题目,会有很多变态的条件和询问,让人摸不着头脑,但是这种题的题解中不乏一种神奇的小方法——离线处理。而且就我目前短浅的见识来看,这种做法多出现在数据结构和贪心中.例题 P1972 [SDOI2009]HH的项链题意给定一个长度为$n$的数列$a$,其中$a_i$是$(1,1000000)$之间的正整数.现在有$m$次询问,每次询问一个区间$[l,r]$中有多少种不同的值. $1 \\le n,m \\le 1000000,1 \\le l,r \\le n$ 解析这个题乍一看像P1558 色板游戏,但是仔细一看,$a_i$的范围竟然是$1e6$,显然不是一个题. 暴力时间复杂度$O(nm)$,数据加强之后堪称$TLE$自动机. 正解对于同一个数,我们肯定只需要记录一次就可以了.但是我们记录那一次呢?最后一次.详细点说,我们设$next_i$表示数字$i$最后一次出现的位置.然后我们通过树状数组来统计次数.为什么要这样呢?因为区间不同数字种类数可以转化为每个数是否出现($1$或者$0$),然后用树状数组通过前缀和相减的方式来针对每一个询问统计区间内有多少不同的数. 回到做法,我们设置了$next$数组来记录数字出现的最后一次位置.这样对于一个询问,我们就找到从$1$到$r$每个数在区间$[1,r]$中最后出现的地方,将那里标记为1.然后$sum(r)-sum(l-1)$即可.因为我们统计的是最后一次出现的位置,这就意味着$l$之前的”$1$”都不在$[l,r]$中,只有$[l,r]$中的”$1$”才属于这个区间.而且因为相同的数字我们没有多次统计,所以只要统计区间中”$1$”的个数就是不同的数的种类数.完美的转化为了前缀和问题. 上代码: #include &lt;cmath&gt; #include &lt;queue&gt; #include &lt;deque&gt; #include &lt;cctype&gt; #include &lt;string&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #define N 1000005 using namespace std; template&lt;class T&gt; inline void read(T &amp;x) { x = 0; char ch = getchar(), w = 0; while (!isdigit(ch)) w = (ch ==&#39;-&#39;), ch = getchar(); while (isdigit(ch)) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); x = w ? -x : x; return; } inline int lowbit(int x) { return -x &amp; x; } struct node{ int l, r, ind, ans; }qsts[N]; int n, m, c[N], rtst[N], a[N]; inline void update(int x, int v) { while (x &lt;= n) { c[x] += v; x += lowbit(x); } return; } inline int sum(int x) { int ret = 0; while (x &gt; 0) { ret += c[x]; x -= lowbit(x); } return ret; } inline bool cmp(node x, node y) { return x.r &lt; y.r; } inline bool cmp1(node x, node y) { return x.ind &lt; y.ind; } int main() { read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); read(m); for (int i = 1; i &lt;= m; ++i) { read(qsts[i].l), read(qsts[i].r); qsts[i].ind = i; } sort(qsts + 1, qsts + 1 + m, cmp); for (int i = 1, mark = 1; i &lt;= m; ++i) { for (int j = mark; j &lt;= qsts[i].r; j++) { if (rtst[a[j]]) update(rtst[a[j]], -1); update(j, 1); rtst[a[j]] = j; } mark = qsts[i].r + 1; qsts[i].ans = sum(qsts[i].r) - sum(qsts[i].l - 1); } sort(qsts + 1, qsts + 1 + m, cmp1); for (int i = 1; i &lt;= m; ++i) { printf(&quot;%d\\n&quot;, qsts[i].ans); } return 0; } 例2 P1955 [NOI2015]程序自动分析题意给出n个形如$x_i=x_j$或者$x_i≠x_j$的关系,问是存在矛盾. 解析这道题是一道很好的并查集练习题,因为我们知道相等关系具有美妙的传递性,而并查集也有美妙的传递性,于是我们可以在得到形如$x_i=x_j$的关系时,将$i$和$j$所在的并查集合并起来,然后如果得到了$x_i≠x_j$的关系的话,那显然是自相矛盾的. 但是存在一个操作次序的问题.如果先得到了$x_i≠x_j$呢?或者如果不止两个,而是多个$x$之间的关系乱序给出,又怎么判断呢?事情变得混乱起来.因此我们不能被它给出的次序牵着鼻子走.我们采用离线的方法,先读入所有关系,因为条件给出的顺序并不影响结果,所以我们先把等于的关系建立好了以后,再一一判断不等于的关系能不能符合.也就是说,把所有关系按照等于$&gt;$不等于的关系先排序,按照所有等于关系建立并查集,然后对于每个不等于关系$x_i≠x_j$,我们判断$i,j$在不在同一个并查集,如果不在,就继续,否则算法结束,输出矛盾. 顺便一说,因为值域很大,但是n很小,所以我们需要先离散化一下. 上代码: #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int totq, n, father[1000005], lisanhua[3000000]; struct node { int from, to, e; }sht[1000005]; inline bool cmp(node x, node y) {//关键 return x.e &gt; y.e; } int findfather(int x) { if (father[x] != x) father[x] = findfather(father[x]); return father[x]; } inline void chushihua(int what) { for (int i = 1; i &lt;= what; i++) father[i] = i; } int main() { cin &gt;&gt; totq; for (int P = 1; P &lt;= totq; P++) { int tot = -1; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; sht[i].from &gt;&gt; sht[i].to &gt;&gt; sht[i].e, lisanhua[++tot] = sht[i].from, lisanhua[++tot] = sht[i].to; sort(lisanhua, lisanhua + tot); int all = unique(lisanhua, lisanhua + tot) - lisanhua; for (int kk = 1; kk &lt;= n; kk++) { sht[kk].from = lower_bound(lisanhua, lisanhua + all, sht[kk].from) - lisanhua; sht[kk].to = lower_bound(lisanhua, lisanhua + all, sht[kk].to) - lisanhua; } chushihua(all); sort(sht + 1, sht + 1 + n, cmp); int qwq = 1; while (sht[qwq].e == 1) { father[sht[qwq].from] = findfather(sht[qwq].from); father[sht[qwq].to] = findfather(sht[qwq].to); father[father[sht[qwq].to]] = father[sht[qwq].from]; qwq++; } bool flag = 0; while (sht[qwq].e == 0) { if (qwq &gt; n) break; if (findfather(sht[qwq].from) == findfather(sht[qwq].to)) { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; flag = 1; break; } qwq++; } if (!flag) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; memset(sht, 0, sizeof(sht)); } return 0; }","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://yoursite.com/categories/经验总结/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/并查集/"}],"author":"i-cookie"},{"title":"8.13模拟赛","slug":"8.13模拟赛","date":"2019-08-13T05:18:56.000Z","updated":"2019-10-09T06:07:14.000Z","comments":true,"path":"2019/08/13/8.13模拟赛/","link":"","permalink":"http://yoursite.com/2019/08/13/8.13模拟赛/","excerpt":"","text":"T1题意有一个$1…n$的排列,现在给出$n$和一个正整数$k$,代表目标是原序列右移$k$次的结果(右移一位代表将当前的序列末尾插入头上,如$12345$右移两次是$45123$)你可以进行任意次操作,每次反转一个区间$[l,r]$,最终使得原序列变为目标序列.最小化操作次数并输出任意一组方案. $0≤k&lt;n≤100$ 解法事实上,这个题完全是结论题因为你可以发现,无论是什么样的情况,都只需要0或1或2或3次就搞定了.因为根本上,它的原始序列是$1…n$,所以右移后一定能分成至多两个有序的部分. 0:没有右移,不需要反转 1:$n=2$且$k=1$时 2:$k=n-1$或$k=1$时,只要先反转$1…n-1$或$2…n$,然后全局反转就可以了 3:其他情况,懒得讲了. T2题意现在给出$n$个在$1…9$之间的正整数,你可以将它们任意排列组合,并分成$k$份,每份组成一个十进制数字.最小化这些数字的最大值. $1≤k≤n≤100000,1≤t≤5$ 解法首先我们可以发现一些性质: 所有这些十进制数字都是按位递增的,也就是没有$54321$这种数 最大值的位数是$ceil(n/k)$位,而有些是$floor(n/k)$位. 我们可以把最大的数丢给位数少的数字. T3题意给定一棵$n$个点的树,从中选出若干个点,使得任意选中的两点之间距离$\\le k$,两点之间的距离定义为树上两点间简单路径经过的边数.询问有多少符合题意的选择方法. $1≤n≤10000,1≤k≤min(500,n)$ 解法我们来考虑如何判断两点之间的距离是不是小于等于$k$.假设我们的两棵子树内的点已经都满足了.那么我们就需要判断子树间点的距离.我们记录离这个点最近的点 即设$f_{i,j}$表示以$i$为根的子树,子树内部已经满足条件了,选出的点中离$i$最近的点的距离为$j$的方案数.合并子树时要满足的条件是:子树间点的距离$&gt;=k,j_1+j_2+2&gt;=k$.新的$j=max(j_1,j_2)+1$ 合并子树时,枚举$j_1,j_2$满足$j_1+j_2+2&gt;=k$.$f_{x,max(j_1,j_2)+1}+=f_{c_1,j_1}×f_{c_2,j_2}$","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"树形结构","slug":"树形结构","permalink":"http://yoursite.com/tags/树形结构/"},{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"}],"author":"i-cookie"},{"title":"基础树形DP:P1040加分二叉树","slug":"加分二叉树","date":"2019-08-12T15:51:00.000Z","updated":"2019-10-09T06:04:28.000Z","comments":true,"path":"2019/08/12/加分二叉树/","link":"","permalink":"http://yoursite.com/2019/08/12/加分二叉树/","excerpt":"","text":"题目描述 设一个n个节点的二叉树tree的中序遍历为（1,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第ii个节点的分数为di,tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下： subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数。 若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。 试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出； （1）tree的最高加分 （2）tree的前序遍历 输入格式 第1行：1个整数n(n&lt;30)，为节点个数。 第2行：n个用空格隔开的整数，为每个节点的分数（分数&lt;100）。 输出格式 第1行：1个整数，为最高加分（Ans≤4,000,000,000）。 第2行：n个用空格隔开的整数，为该树的前序遍历。 解法这个题目的一个重要条件是你求解的二叉树的中序遍历是（1,2,3…n)。在二叉树的中序遍历中，对于任意一个点i，它前面的数一定都在它的左子树中， 它右边的数可能在它的右子树中（挺显然的吧）。因此中序遍历区间[1,i]一定是以某个$a_j$(j∈[1,i])为根的子树(还算显然吧). 因此我们可以对于每一段区间试着选出一个根,然后算出以它为根的最大值,最后记录答案. 具体来说: 设$f_{i,j}$表示以点$[i,j]$组成一棵二叉树的最大加分,接下来我们来枚举断点k.这个断点事实上代表了树根,即我们令$i$到$k-1$是左子树,$k+1$到$j$是右子树,然后我们递归下去,退回以后更新答案,枚举下一个$k$.最终目标:$f_{1,n}$.过程中如果记录过答案就直接返回记录的值,也就是应用树形DP常用的做法:记忆化搜索. 代码: int dfs(int l, int r) { if (l &gt; r) return 1;//不合法判断 if (l == r) {//递归到叶子节点 root[l][r] = l;//以它自己为根 return val[l]; } if (maxinum[l][r]) return maxinum[l][r];//记忆化的关键 int k, ans = -1000000000; for (int i = l; i &lt;= r; ++i) { int temp = dfs(l, i - 1) * dfs(i + 1, r) + val[i];//枚举了断点,递归下去更新答案 if (temp &gt; ans) {//更新答案 ans = temp; k = i; } } root[l][r] = k;//记录最合适的根 maxinum[l][r] = ans;//记录最大答案 return ans; } 这样我们就做完了第一问别忘了,这题还有第二问[允悲]第二问要求我们输出前序遍历,也就是先输出根,后输出左儿子,后输出右儿子.其实我们在第一问中已经得到了这个问题的答案…左儿子,也就是左子树的根,右儿子,也就是右子树的根.我们选完根,第二问就已经得到答案了.我们只需要从$root_{1,n}$开始,先递归$root_{1,root_{1,n}-1}$再递归$root_{root_{1,n}+1,n}$,然后以此类推就可以了. 可能上面说的有点绕,具体看代码吧: void findroot(int l, int r) { if (l &gt; r) return; cout &lt;&lt; root[l][r] &lt;&lt; &quot; &quot;; findroot(l, root[l][r] - 1); findroot(root[l][r] + 1, r); return; } 是不是很简短呢? 哦对了,别忘了开long long.","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"树形结构","slug":"树形结构","permalink":"http://yoursite.com/tags/树形结构/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}],"author":"i-cookie"},{"title":"专题:四维DP","slug":"四维DP","date":"2019-08-11T03:14:32.000Z","updated":"2019-10-28T15:43:50.000Z","comments":true,"path":"2019/08/11/四维DP/","link":"","permalink":"http://yoursite.com/2019/08/11/四维DP/","excerpt":"","text":"蒟蒻在DP之路上求索着 T1 P1004 方格取数题目描述 设有$N\\times N$的方格图$(N≤9)$，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字0。如下图所示（见样例）: A 0 0 0 0 0 0 0 0 0 0 13 0 0 6 0 0 0 0 0 0 7 0 0 0 0 0 0 14 0 0 0 0 0 21 0 0 0 4 0 0 0 0 15 0 0 0 0 0 0 14 0 0 0 0 0 0 0 0 0 0 0 0 0 0B 某人从图的左上角的A点出发，可以向下行走，也可以向右走，直到到达右下角的B点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。此人从A点到B点共走两次，试找出2条这样的路径，使得取得的数之和为最大。 输入格式 输入的第一行为一个整数N（表示$N \\times N$的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的0表示输入结束。 输出格式 只需输出一个整数，表示2条路径上取得的最大的和。 解法其实如果只走一条路径完全可以直接二维DP出来。但是这题有一个特殊的地方， 那就是取走的地方会变为0.这就不允许我们分别DP。在这种情况下，我们要参考数据范围，然后发现，可以设$f[i][j][p][q]$表示第一条路走到了$(i,j)$,第二条路走到了$(p,q)$,的最大值。因为第二条路和第一条路的两个端点是一样的，所以可以当成从同一起点出发的两条路了。然后转移时就枚举两条路分别是从上面还是左面转移来的即可。 代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; int s[10][10], n, f[10][10][10][10]; inline int max(int x, int y) { return x &gt; y ? x : y; } int main() { cin &gt;&gt; n; do { int y, x, c; cin&gt;&gt;y&gt;&gt;x&gt;&gt;c; if(y == 0 &amp;&amp; x == 0 &amp;&amp; c == 0) break; s[y][x] = c; }while (1); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) for (int p = 1; p &lt;= n; p++) for (int q = 1; q &lt;= n; q++) { f[i][j][p][q] = max(f[i][j][p][q], f[i - 1][j][p - 1][q] + s[p][q]); f[i][j][p][q] = max(f[i][j][p][q], f[i - 1][j][p][q - 1] + s[p][q]); f[i][j][p][q] = max(f[i][j][p][q], f[i][j - 1][p - 1][q] + s[p][q])； f[i][j][p][q] = max(f[i][j][p][q], f[i][j - 1][p][q - 1] + s[p][q]); if (i != p || j != q) f[i][j][p][q] += s[i][j]; } cout &lt;&lt; f[n][n][n][n] &lt;&lt; endl; return 0; } T2 P1541 乌龟棋题目背景小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。 题目描述 乌龟棋的棋盘是一行N个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一的起点，第N格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。 乌龟棋中M张爬行卡片，分成4种不同的类型（M张卡片中不一定包含所有4种类型的卡片，见样例），每种类型的卡片上分别标有$1,2,3,4$四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。 游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。 很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。 现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？ 输入格式 每行中两个数之间用一个空格隔开。 第1行2个正整数N,M，分别表示棋盘格子数和爬行卡片数。 第2行N个非负整数，a_1,a_2,…,a_N。其中a_i表示棋盘第i个格子上的分数。 第3行M个整数，b_1,b_2,…,b_M，表示M张爬行卡片上的数字。 输入数据保证到达终点时刚好用光M张爬行卡片。 输出格式 1个整数，表示小明最多能得到的分数。 解法至此我们已经基本上看出来了四维DP的使用前提： 二维通常不符合题意 数据范围能承受的住 题目中的关键信息往往可以关联到四个种类的信息。 在这道题中，卡片的数目已经限定有且只有4种了，且每种卡片的使用互相独立，而且数据范并不大，因此我们考虑设$f[i][j][p][q]$表示第一种卡片用了i张，第二种卡片用了j张，第三种卡片用了p张，第四种卡片用了q张，所能得到的最大分数。因为题目保证所有卡片都用完，所以目标是$f[c1][c2][c3][c4]$.转移的时候直接根据用的张数就可以直接算出现在在哪一个点。 代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; int n, c, c1, c2, c3, c4, f[45][45][45][45], s[355]; inline int max(int x, int y) { return x &gt; y ? x : y; } int main() { cin &gt;&gt; n &gt;&gt; c; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; s[i]; for (int i = 1; i &lt;= c; i++) { int x; cin &gt;&gt; x; if (x == 1) c1++; if (x == 2) c2++; if (x == 3) c3++; if (x == 4) c4++; } f[0][0][0][0] = s[1]; if (c4 &gt; 0) f[1][0][0][0] = s[5]; if (c3 &gt; 0) f[0][1][0][0] = s[4]; if (c2 &gt; 0) f[0][0][1][0] = s[3]; if (c1 &gt; 0) f[0][0][0][1] = s[2]; for (int i = 0; i &lt;= c4; i++) for (int j = 0; j &lt;= c3; j++) for (int p = 0; p &lt;= c2; p++) for (int q = 0; q &lt;= c1; q++) { if (i == 0 &amp;&amp; j == 0 &amp;&amp; p == 0 &amp;&amp; q == 0) continue; if (i &gt; 0) f[i][j][p][q] = max(f[i][j][p][q], f[i - 1][j][p][q] + s[i * 4 + j * 3 + p * 2 + q * 1 + 1]); if (j &gt; 0) f[i][j][p][q] = max(f[i][j][p][q], f[i][j - 1][p][q] + s[i * 4 + j * 3 + p * 2 + q * 1 + 1]); if (p &gt; 0) f[i][j][p][q] = max(f[i][j][p][q], f[i][j][p - 1][q] + s[i * 4 + j * 3 + p * 2 + q * 1 + 1]); if (q &gt; 0) f[i][j][p][q] = max(f[i][j][p][q], f[i][j][p][q - 1] + s[i * 4 + j * 3 + p * 2 + q * 1 + 1]); } cout &lt;&lt; f[c4][c3][c2][c1] &lt;&lt; endl; return 0; } T3 P1006 传纸条题目描述小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个m行n列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标$(1,1)$，小轩坐在矩阵的右下角，坐标$(m,n)$。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。 在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。 还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以用一个0-100的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这2条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的2条路径。 输入格式输入文件，第一行有2个用空格隔开的整数m和n，表示班里有m行n列。 接下来的m行是一个$m\\times n$的矩阵，矩阵中第i行j列的整数表示坐在第i行j列的学生的好心程度。每行的n个整数之间用空格隔开。 输出格式输出文件共一行，包含一个整数，表示来回2条路上参与传递纸条的学生的好心程度之和的最大值。 解法其实这道题因为放在了这个专题里而变得很简单。如果平时看到这道题，我们很可能会首先考虑二维DP，即先找出最大的一条路，再找另一条最大的路。但是这是错误的。因为题目要求两条路没有公共点，也就是说直接找到最大的一条路有可能会使得其他答案被阻断从而出现了第一条路优但是全局不优的结果。因此我们只能考虑四维DP。设$f[i][j][p][q]$表示第一条路到了$(i,j)$，第二条路到了$(p,q)$的最大值，然后我们用类似第一题的做法来解决这个题就可以了。 代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; int n, m, f[52][52][52][52], c[50][50]; inline int max(int x, int y) { return x &gt; y ? x : y; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; c[i][j]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) for (int p = 1; p &lt;= n; p++) for (int q = j + 1; q &lt;= m; q++) { f[i][j][p][q] = max(f[i][j][p][q], f[i - 1][j][p - 1][q] + c[p][q] + c[i][j]); f[i][j][p][q] = max(f[i][j][p][q], f[i][j - 1][p][q - 1] + c[p][q] + c[i][j]); f[i][j][p][q] = max(f[i][j][p][q], f[i - 1][j][p][q - 1] + c[p][q] + c[i][j]); f[i][j][p][q] = max(f[i][j][p][q], f[i][j - 1][p - 1][q] + c[p][q] + c[i][j]); } cout &lt;&lt; f[n][m - 1][n - 1][m] &lt;&lt; endl; return 0; } T4 [JSOI2008]Blue Mary的职员分配题目描述 ​ 由于Blue Mary呕心沥血的管理，Blue Mary的网络公司蒸蒸日上。现在一共拥有了n名职员，可惜没有任何的金钱和声誉。平均每名每天职员都可以给公司带来x单位金钱或者y单位声誉（名利不能双全）。并且可以花费z单位的金钱在人才交易市场发布广告招聘职员，每次发布广告三天以后就会招聘到一名职员，并且必须在发布广告并且招聘到职员的那一天才能发布下一次广告。 ​ Blue Mary计划以最快的时间获得至少A单位金钱和至少B单位声誉，请你计算一下他至少需要多少时间才能达到他的目标。 数据范围与约定 对于所有的数据, $1\\le n,x,y,z,A,B\\le 20$. 解法​ 这可能是我目前遇到最强的DP题了吧. ​ 题目中给了大量的信息,我们发现数据范围异常的小,因此我们最多可以把状态加到4维.接下来的转移让我怀疑人生. ​ 考虑到在现有的人中,可以有不同的人挣钱,其他人挣声誉,所以一个状态可以导致多个状态,同样的,一个状态也可以由多个状态转移过来.因此为了方便思考,选择刷表法而不是填表法.期初我试图使用三维或者二维DP,但是发现转移可能会变得非常变态,所以只能考虑四维(估计数据范围也是照着四维给的).但是这四维设什么呢?来看看题目中的信息:我们要求的是达到一定金钱和声誉的时间,所以相关的肯定要记录现在已有的金钱和声誉.而只记录这两个显然会使得状态无从转移,所以我们再加上与现在的人数有关的一维.而人数可以通过打广告来增加,所以我们需要再加一个打广告的维. ​ 看看我们得到了什么.设$f[i][a][b][j]$表示现在我们有i个人,手中有a的金钱和b的声誉,距离上一次发出广告已经过去了j天(个人怀疑这一维是怎么用人脑想出来的).然后就是转移了.显然,人数会直接影响a,b.而j的不同会直接导致i的不同.我们应该按照j来分类讨论. if j == 0,即打广告的时刻 f[i][a][b][0] -&gt; f[i][下个状态的钱][下个状态的声誉][0];//相当于推迟打广告,这个时刻不打广告 if 下个状态的金钱 &gt;= z f[i][a][b][0] -&gt; f[i][下一状态的钱-z][下个状态的声誉][1];//相当于这一时刻打了广告,前提是钱够 if j == 3,即招到人的时刻 f[i][a][b][3] -&gt; f[i+1][下个状态的钱][下个状态的声誉][0];//不继续打广告 if 下个状态的金钱 &gt;= z f[i][a][b][3] -&gt; f[i+1][下个状态的钱-z][下个状态的声誉][1];//刚招到人又打了广告 else f[i][a][b][j] -&gt; f[i][a][b][j+1];//已经打了广告,除了等到人来别无选择 这就是大致的思路.接下来可以用上面的伪代码大致对照一下实际代码来加深理解 int main() { read(n), read(x), read(y), read(z), read(A), read(B); ans = inf; memset(f, 0x3f, sizeof(f)); f[n][0][0][0] = 0; for (int i = n; i &lt;= 40; ++i)//四重循环 for (int j = 0; j &lt;= 3; ++j)//这个要放在外层,不然会WA for (int a = 0; a &lt;= max(A, z); ++a) for (int b = 0; b &lt;= B; ++b) { if (f[i][a][b][j] &gt;= ans) continue;//劣解没必要讨论 int nowans = f[i][a][b][j];//缩短代码长度 if (a &gt;= A &amp;&amp; b &gt;= B) { ans = min(ans, nowans); continue; } for (int k = 0; k &lt;= i; ++k) { int nowa = min(a+k*x, max(A, z)), nowb = min(B, b+y*(i-k));//再次缩短代码长度 if (j == 0) {//讨论这个状态打还是不打 f[i][nowa][nowb][0] = min(f[i][nowa][nowb][0], nowans + 1); if (nowa &gt;= z) f[i][nowa-z][nowb][1] = min(f[i][nowa-z][nowb][1], nowans+1); } else if (j == 3) {//讨论这个状态打还是不打 f[i+1][nowa][nowb][0] = min(f[i+1][nowa][nowb][0], nowans+1); if (nowa &gt;= z) f[i+1][nowa-z][nowb][1] = min(f[i+1][nowa-z][nowb][1], nowans + 1); } else f[i][nowa][nowb][j+1] = min(f[i][nowa][nowb][j+1], nowans + 1); //只能等着 } } cout &lt;&lt; ans &lt;&lt; endl; return 0; }","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://yoursite.com/categories/经验总结/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}],"author":"i-cookie"},{"title":"8.08 贪心","slug":"8.8贪心","date":"2019-08-08T11:35:37.000Z","updated":"2019-10-09T04:59:14.000Z","comments":true,"path":"2019/08/08/8.8贪心/","link":"","permalink":"http://yoursite.com/2019/08/08/8.8贪心/","excerpt":"","text":"T1问题给你一个长度为n的数字,可以删掉其中的m位,使得结果数字最小. 解法 首先考虑m = 1的情况.此时我们为了降低字典序,显然要从前往后找到第一个下降的数字,然后删掉它.这样起到了降低字典序的效果.然后考虑一般情况,其实相当于m次这个过程.这体现了贪心的核心:单步最优解导致全局最优解. 我们删去了m个数字,这些数字也可以组成一个序列.如果当前贪心不是最优解,那与最优解相比,肯定与最优解相比至少会有一对数,在原序列中位置不同.如果当前贪心删去的数字位置在最优解的后面,那就说明最优解比贪心删去的数字小或者相等,显然这样的话我们删去最优解更优而不是删去当前贪心的位置.同样,如果在前面也可以证明我们的贪心就是最优解. 该问题也可以转化为取出序列中的n-m个数字.那么贪心策略就是在前m+1位中选最小值,然后前面删掉.然后重复这个过程.因为只需要保证最后有足够的数可以选就行了,所以选第一个时,只要保证最后有至少n-m-1个数就行了.以此类推.T2问题给你一个长度为n的序列,其中的0可以视为任何正整数,求它的最长上升子序列.解法设dp[i]表示以a[i]结尾的lis的长度.(a[i]!=0)dp[i] = max{dp[j]} + 1,其中a[i]-a[j]&gt;x(x为[i,j]之间0的个数).0的个数可以用前缀和优化.T3问题给出一个长度为n的序列a,其中每个数都可以看做一个k位二进制数,你可以将序列中任意一个数按位取反,目标是使得其中异或和不为0的区间尽可能的多n&lt;=2e5,k&lt;=30解法区间的异或和可以转化成前缀和问题,xorsum[i,j] = sum[j] xor sum[i - 1]………T4问题给出一些边,选出四条边组成矩形,最小化周长的平方与面积的商.解法众所周知,周长确定的情况下,越接近正方形面积越大,所以就选择最接近的两条边就好啦. 具体证明的话,就表示成a / b + b / a最小,也就是x + 1 / x最小,由双钩函数的性质可以知道,比例越接近1越合适. T5问题给定一个n个节点的树,点权是2^i,现在在保证连通性的情况下,从树中删去k个点,最大化剩余节点点权和.1e6,3s. 解法显然点i的权值比Σa[1,i-1]还要大.所以我们选择n号点作为根,然后贪心地判断n-1,n-2..能不能被保留.","categories":[{"name":"课堂笔记","slug":"课堂笔记","permalink":"http://yoursite.com/categories/课堂笔记/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"}],"author":"i-cookie"},{"title":"重要基础数据结构——单调栈","slug":"单调栈","date":"2019-08-03T16:29:39.000Z","updated":"2019-10-09T04:57:20.000Z","comments":true,"path":"2019/08/04/单调栈/","link":"","permalink":"http://yoursite.com/2019/08/04/单调栈/","excerpt":"","text":"例题例题1 SP1805 Largest Rectangle in a HistogramA histogram is a polygon composed of a sequence of rectangles aligned at a common base line. The rectangles have equal widths but may have different heights. For example, the figure on the left shows the histogram that consists of rectangles with the heights 2, 1, 4, 5, 1, 3, 3, measured in units where 1 is the width of the rectangles: Usually, histograms are used to represent discrete distributions, e.g., the frequencies of characters in texts. Note that the order of the rectangles, i.e., their heights, is important. Calculate the area of the largest rectangle in a histogram that is aligned at the common base line, too. The figure on the right shows the largest aligned rectangle for the depicted histogram. 一句话题意：求一个最大子矩阵看到这个问题，我们应该先在脑内想一些特殊且简单的模型，然后推广到更一般的情况。比如，如果所有矩形都一样高会怎样，显然，答案就是整个矩阵。那么，如果矩形高度是单调的又会怎样呢？同样的，找到一个矩形的高，显然此时子矩阵的高已经被限制住了。那么它现在要做的就是尽量往左，右扩展。这样就能使得高一样的情况下宽尽量大。然后尝试每一个这样的矩形的高就可以了。 既然这样，矩形高度并不单调的时候，我们又应该怎么办呢？回顾之前的过程，我们得到一个新的矩形的高的时候，都会将它往左右扩展到边界。那么矩形高度并不单调的时候就会出现如下情形： 显然，被灰色矩形截下来的上面凸出的部分已经没用了。因为后面的矩形即便是高度增加到很高，扩展边界时也不可能越过波谷达到这块凸出的地方了。因此，我们直接将它们扔掉！继续这样下去。为了实现这一想法，我们可以建立一个栈，里面存储我们找到的矩形，而且要时刻保持栈中矩形的高度单调递增，这样就可以应用我们之前设想的单调递增模型来解决最大面积问题。这种经典算法被称作单调栈。 详细一点来说，我们需要进行这样的操作： 当我们遇到一个新的矩形的时候， 这个矩形比栈顶矩形更高。 那么我们将它直接入栈，不违反我们的单调递增原则 这个矩形比栈顶矩形更矮 正如上图的情况，我们遇到一个比上一个矩形矮的矩形。那么我们可以丢掉“凸出来的那一部分”。怎么丢掉呢？那就是只留下它们的宽度（因为宽度对新矩形的面积有贡献），然后用他们的宽度乘上它们的高度来更新答案，然后丢掉它们的高度（因为对新矩形没贡献）。 从操作上看来，它表现为将所有大于当前矩形高度的矩形累加并储存起来，然后更新答案并将它们退掉，将这个宽度加在当前矩形上，使得它成为一个有它自己高度和前面退掉的矩形的宽度的新矩形，然后将它存到栈中，仍然不影响单调递增原则。这样O(n)遍历一次，就可以得到一个高度单调递增，宽度不尽相同的矩阵栈。然后将这些矩形弹出，用相同的方法更新答案，注意，最好增加一个高度为0的矩形a[n+1]，以免剩余矩形弹出不干净。 练习题例二 P1169 [ZJOI2007]棋盘制作题目描述国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个8×8大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。 而我们的主人公小Q，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友小W决定将棋盘扩大以适应他们的新规则。 小Q找到了一张由N×M个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。小Q想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。 不过小Q还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。 于是小Q找到了即将参加全国信息学竞赛的你，你能帮助他么？ 输入格式包含两个整数NN和MM，分别表示矩形纸片的长和宽。接下来的N行包含一个N×M的01矩阵，表示这张矩形纸片的颜色（0表示白色，1表示黑色）。 输出格式包含两行，每行包含一个整数。第一行为可以找到的最大正方形棋盘的面积，第二行为可以找到的最大矩形棋盘的面积（注意正方形和矩形是可以相交或者包含的）。 问题分析这道题要求我们找出满足任意相邻格子颜色不同的最大正方形和最大矩形。我们将这个问题的第一问使用了DP而非单调栈，所以我们重点回顾第二问： 怎么求最大矩形 还记得例一吗，例一给出了一个序列，我们将一维的序列的数字看作高度，将它“提起来”变成二维。这个题上来就是二维，看似与例一不同，其实是例一的“变种”。我们先来考虑前i行，对于每个格子，它上面都有一些另外的格子，但是颜色不一定是如何的。然而我们需要求黑白相间的最大面积，那么我们可以从每一个元素向上扩展出黑白相间的高度，这样这个问题就瞬间变成了例一。我们只需要从每一行向上扩展出高度，然后就可以建立单调栈求解了！当然也要注意同一行相邻格子的颜色哦。 关键代码 for (int j = 1; j &lt;= m; ++j) { for (int i = 1; i &lt;= n; ++i) {//为了降低时间复杂度,采用按列递推的方式 line[i][j].col = b[i][j];//记录当前点的颜色 line[i][j].h = 1;//初始化高度 if (b[i][j] == b[i - 1][j])//如果和上一行颜色不同 line[i][j].h = line[i - 1][j].h + 1;//直接继承上一列的长度 }//否则就保持长度为1. } for (int bot = 1; bot &lt;= n; ++bot) {//bot即bottom,也就是我们建立单调栈的一行 int flag = -1; for (int i = 1; i &lt;= m; ++i) {//扫描这一行 if (s[top] &lt; line[bot][i].h &amp;&amp; (flag == -1 || flag == line[bot][i].col)) {//如果这一格向上高度更高 s[++top] = line[bot][i].h, w[top] = 1;//直接入栈,记录宽度为1 flag = line[bot][i].col;//记录栈顶颜色(也就是注意同一行的相邻格子之间的颜色 } else {//如果遇到高度低的 int totwide = 0;//记录弹出总宽度 while (top &gt; 0 &amp;&amp; (s[top] &gt; line[bot][i].h || flag != line[bot][i].col)) {//栈非空且矮或与栈顶颜色不同 totwide += w[top];//累加宽度 ans2 = max(ans2, (long long)totwide * s[top]);//更新答案 top--;//退栈 } s[++top] = line[bot][i].h;//将新形成的具有自己的高度和累加的宽度的新矩形加入栈中. if (flag == line[bot][i].col)//如果颜色相同,代表新矩形可以替代原来处于栈顶的矩形. w[top] = totwide + 1;//可以累加宽度 else w[top] = 1;//否则只能作为新的起点 flag = line[bot][i].col;//记录栈顶颜色. } } if (top &gt; 0) {//这一行扫完了,退栈 int totwide = 0; while (top &gt; 0) { totwide += w[top];//累加宽度 ans2 = max(ans2, (long long)totwide * s[top]);//更新答案 top--;//退栈 } } } cout &lt;&lt; ans2 &lt;&lt; endl; 这样问题就解决啦！欢迎批评和指正！","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://yoursite.com/categories/经验总结/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"单调栈","slug":"单调栈","permalink":"http://yoursite.com/tags/单调栈/"}],"author":"i-cookie"},{"title":"7.31 \"简单\"(大嘘)DP","slug":"7.31简单DP","date":"2019-07-31T06:30:36.000Z","updated":"2019-10-09T04:55:30.000Z","comments":true,"path":"2019/07/31/7.31简单DP/","link":"","permalink":"http://yoursite.com/2019/07/31/7.31简单DP/","excerpt":"","text":"T1问题给定一个n * m的矩阵,要求在每一个格子填入0或1,使得没有相邻的1,问方案数有多少 解法用f[i][j][s]代表现在在(i,j),状态为s的方案数.状态S为一个数,将它转化成二进制后,每一位的0或1代表目前最晚填完的m个格子的方案数,也就是从[i-1][j]到[i-1][m];从[i][1]到[i][j-1]的这m个.这样就可以一直更新了. T2问题给定n个字符串,构造一个串S使得S包含这些所有串,且长度最小. 解法[数据删除] T3问题现在有n个点,对于第i个点和第j个点,你可以选择不连接,也可以在c[i,j]条颜色不一样的边中选一条连接他们.要求最终将这些点连成一个连通图,而且没有自环,问方案数 mod 1e9+7. n &lt;= 15 解法[数据删除] T4问题给出一行N个点,在(u,v)之间连边的条件是|u-v|&lt;=k,即下标相差不超过k.问连出一张欧拉图的方案数. k &lt;= 5,n &lt;= 1e5 解法斯坦纳树 T5问题给出一颗n个节点的树,树边边权给出.计算出树上每个节点的最远点到他的距离. n&lt;=1e5 解法[数据删除] T6问题给定一棵n个点的树,走L步使得经过的点权和最大 n &lt;= 5000 解法[数据删除] T7问题给定A,B,求出[A,B]中各位数字之和能整除原数的数的个数. A,B&lt;=10^18 解法T8问题定义不含前导0且相邻两个数之差至少为2的数为windy数,问A和B之间,包括A和B,共有多少个windy数? 解法[数据删除] T9问题给定一棵树,从中找出k个点,使得Σdis(a[i],a[i+1])最小 解法先考虑k==n的时候,你会发现,除了起点和终点之间的那一条链以外,所有的边都经过了两次,即一次进入点一次出点.因此k==n时题目等价于寻找最长链. 考虑更一般化的情况,问题变成寻找一个大小为k的子集来处理.在这里,这个点集显然是一个连通的子树,所以就要用树上背包,斯坦纳树等我不会也听不懂的奇怪知识点来[数据删除].","categories":[{"name":"课堂笔记","slug":"课堂笔记","permalink":"http://yoursite.com/categories/课堂笔记/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}],"author":"i-cookie"},{"title":"luogu P2014 选课","slug":"选课","date":"2019-07-31T01:58:14.000Z","updated":"2019-10-11T11:28:30.000Z","comments":true,"path":"2019/07/31/选课/","link":"","permalink":"http://yoursite.com/2019/07/31/选课/","excerpt":"","text":"题目描述在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有N门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择M门课程学习，问他能获得的最大学分是多少？ 输入格式第一行有两个整数N,M用空格隔开。(1&lt;=N&lt;=300,1&lt;=M&lt;=300) 接下来的N行,第I+1行包含两个整数ki和si, ki表示第I门课的直接先修课，si表示第i门课的学分。若ki=0表示没有直接先修课（1&lt;=ki&lt;=N, 1&lt;=si&lt;=20）。 输出格式只有一行，选M门课程的最大得分。 解决问题“先修课”的关系就如同树上的父子节点一样.因此通过以”先修课关系”为依据连好边以后,这个问题的模型将呈现树形.这是一道树形DP的经典题目.我们设f[i][j]表示在以i为根的这棵树内选取k门课,所能得到的最大学分和.为什么能这样呢?因为树形非常符合DFS的模型,能够做到不重不漏,所以树形DP通常用递归的方式实现.那么我们显然需要考虑到设置状态的时候应该与什么有关.DFS时,我们总是一次次到达子树的根节点,然后再继续考虑,所以我们应当将其中一维与子树的根相关.然后我们想要得到最大学分,这要通过适当的选择科目来实现.因此我们枚举选择j门课,能得到的最大学分.最终目标f[0][m]. 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;cctype&gt; #include &lt;utility&gt; #include &lt;vector&gt; using namespace std;//树形DP经典例题_选课 inline void read(int &amp;x) { x = 0; char ch = getchar(), w = 0; while (!isdigit(ch)) w = (ch == &#39;-&#39;), ch = getchar(); while (isdigit(ch)) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); x = w ? -x : x; return; } int n, m, sc[305], f[305][305];//f[i][j]表示以i为根的子树中选j门课能得到的最多学分 vector&lt;int&gt; son[305]; void tree_dp(int now) {//树形DP惯用记忆化搜索 f[now][0] = 0;//初值为0; for (int i = 0; i &lt; son[now].size(); ++i) {//扫描所有儿子 int v = son[now][i]; tree_dp(v);//递归到底再从叶子返回根 for (int t = m; t &gt;= 0; --t)//倒序枚举选几门课,因为每一节课只能选一次,代表这属于01背包,如果正序就是完全背包了. for (int j = t; j &gt;= 0; --j) if (t - j &gt;= 0) f[now][t] = max(f[now][t], f[now][t - j] + f[v][j]);//相当于从目前枚举出的总课数中, //有j门是在儿子i选的,其他的是在其他儿子选的. } if (now != 0) for (int t = m; t &gt; 0; --t) f[now][t] = f[now][t - 1] + sc[now];//因为树根也要选,所以所有情况都要加上树根 return; } int main() { read(n), read(m); // memset(f, 128, sizeof(f)); for (int i = 1, a, b; i &lt;= n; ++i) {//建树,读入score read(a), read(b); son[a].push_back(i), sc[i] = b; } tree_dp(0);//从树根开始dp ,这个树根是超级原点 cout &lt;&lt; f[0][m] &lt;&lt; endl;//最终目标,在以0为根的子树中选m门课的最高学分 return 0; } 欢迎批评和指正","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"树形结构","slug":"树形结构","permalink":"http://yoursite.com/tags/树形结构/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}],"author":"i-cookie"},{"title":"7.30 \"简单\"(大嘘)DP","slug":"7.30简单DP","date":"2019-07-30T03:36:20.000Z","updated":"2019-10-09T04:51:50.000Z","comments":true,"path":"2019/07/30/7.30简单DP/","link":"","permalink":"http://yoursite.com/2019/07/30/7.30简单DP/","excerpt":"","text":"T1题目给定n个括号序列,要求从中选出若干个拼起来,使得拼成的序列为合法的括号序列,在此基础上使得长度尽量长. n &lt;= 1000,总长度 &lt;= 10000 解法对于一个括号序列来说,如果将其中匹配的括号去掉的话,它的形式会变成左边一串右括号,右边一串左括号.比如)()))((,去掉匹配括号之后就形如)))((,可以用二元组(3,2)来表示. 设f[i][j]表示考虑了前i个序列,前缀和为j.左括号为1,右括号为-1,那么一个括号序列合法的充要条件是任意一个前缀和都&gt;=0.所以只要两个括号序列合并的时候前缀和大于等于0就可以转移. 再来考虑顺序.比如(())和))((相比,(())更优,因为它的最小前缀和更大.或者考虑二元组的形式(A,B)和(A’,B’).当A&lt;B,A’&lt;B’,此时比较A和A’的大小,将A小的放在前面.A&gt;B,A’&gt;B’, T2题目给定n个括号序列,要求删掉一些位置,并且把所有序列适当排列,使得接起来组成一个合法括号序列,且长度最长.n&lt;=100000. 解法此题跟DP没有关系.(大雾)考虑一个括号序列表示成(A,B),那么要使得它合法,就要去掉A+B个位置. T3题目令S是一个括号序列,定义f(S)表示把所有匹配括号删除之后S的长度。给定一个括号序列，求一个子串S，使得f(s)最大. 长度 &lt;= 100000 解法[不会] T4题目给定一个矩阵,每个位置有全职.一个子矩阵的权值定义为包含的每个位置的权值和.两个不相交的子矩阵的pair的权值定义为两个子矩阵的权值的积.求所有pair的权值和矩阵大小不超过1e6 解法将情况分成三种可能 被横线分开 被竖线分开 被两种线同时分开 利用容斥算出来,再加上二位前缀和.为了不重复计算,我们假定被横线分开时,上矩阵贴横线,被竖线分开时,左矩阵贴竖线,其他同理.设f[x][y]表示右下角是(x,y)的矩阵的权值和 f[x][y]=ΣiΣjsum(i,j,x,y); T5问题有n个白点和m个黑点.求是否存在一个由白点组成的简单凸多边形,内部恰好有k个黑点.为了方便假设不存在三点共线的情况. n,m,k&lt;=100 解法[不会] T5题目有n个数a[1]到a[n],你可以把每个数+1,-1或不变,要求他们最终的gcd最大. n &lt;= 100000, a[i] &lt;= 10^12 解法[不会] T6问题有n个数a1到an,要从中选出一个长度为k的子序列形成b,满足b[i]&gt;b[i-1],b[i+1]-b[i]&gt;b[i]-b[i-1],要求输出一组方案,没有输出无解. n &lt;= 20000,k &lt;= 100 解法记f[i][j]表示结尾是i,目前长度为j,最小的b[i]-b[i-1].f[i][1]=0. T7问题有一个程序包含m个嵌套的for,每个for形如for(x=l;x&lt;=r;x++);其中x互不相同,l和r可能是之前某一层的变量可能是常数,若l是常数则一定是1,若r是常数则一定是n.求这个程序的复杂度分析中,n的最高次方以及最高次方上的常数. n &lt;= 20 解法[不会] T8问题给定一个二叉树的前序遍历和中序遍历的结果,其中一些位置丢失了,求有多少种合法的二叉树 n &lt;= 100 解法","categories":[{"name":"课堂笔记","slug":"课堂笔记","permalink":"http://yoursite.com/categories/课堂笔记/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}],"author":"i-cookie"},{"title":"luogu P2341 受欢迎的牛","slug":"popular cow","date":"2019-07-30T02:53:12.000Z","updated":"2019-10-09T04:50:08.000Z","comments":true,"path":"2019/07/30/popular cow/","link":"","permalink":"http://yoursite.com/2019/07/30/popular cow/","excerpt":"","text":"题目描述每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶 牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜欢”是可以传递的——如果A喜 欢B，B喜欢C，那么A也喜欢C。牛栏里共有N 头奶牛，给定一些奶牛之间的爱慕关系，请你 算出有多少头奶牛可以当明星。 输入格式第一行：两个用空格分开的整数：N和M 第二行到第M + 1行：每行两个用空格分开的整数：A和B，表示A喜欢B 输出格式第一行：单独一个整数，表示明星奶牛的数量 解决问题显然,”喜欢”是单向的,具有传递性的.因此我们把奶牛和奶牛之间的”喜欢”抽象成有向图中的边,而每一只奶牛都是点.这个有向图并不能保证没有环,也就是说,可能出现一圈奶牛相互喜欢,那么他们在这个小群体里就都是明星.这个小群体,叫做强连通分量.所以我们通过tarjan将所有的强连通分量分别缩成点,同时记录一下这个点有多大,这样就省去了很多遍历的步骤. 如果一个强连通分量里有奶牛指向外面,那么这个强连通分量中的所有奶牛都喜欢这条边指向的奶牛.至于能够成为明星的强连通分量,那一定是所有分量都最终指向这个分量,且这个分量没有出边.然后这个分量里所有的奶牛就都是明星了.注意要记下每个强连通分量里有多少奶牛. 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;cctype&gt; #define N 10005 #define M 50005 using namespace std; inline void read(int &amp;x) { x = 0; char ch = getchar(), w = 0; while (!isdigit(ch)) w = (ch == &#39;-&#39;), ch = getchar(); while (isdigit(ch)) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); x = w ? -x : x; return; } int n, m, noe, chudu[N], ans, noz; int to[M], next[M], head[N]; int noc, members[N], c[N]; int instack[N], stack[N], top, dfn[N], cnt, low[N]; inline void addedge(int from, int t) { to[++noe] = t; next[noe] = head[from]; head[from] = noe; return; }//加边 void tarjan(int now) { dfn[now] = ++cnt, low[now] = dfn[now], instack[now] = 1, stack[++top] = now; for (int i = head[now]; i; i = next[i]) { if (!dfn[to[i]]) tarjan(to[i]), low[now] = min(low[now], low[to[i]]); else if (instack[to[i]]) low[now] = min(low[now], dfn[to[i]]); } if (low[now] == dfn[now]) { noc++;//发现了一个新的强连通分量 while (stack[top] != now) { instack[stack[top]] = 0; c[stack[top]] = noc;//c[i]代表i所属的连通块的编号 top--; members[noc]++;//记录这个新的强连通分量里有多少头奶牛 } top--; instack[now] = 0; c[now] = noc; members[noc]++;//这里也不能忘了 } return; } int main() { read(n), read(m); for (int i = 1, x, y; i &lt;= m; ++i) { read(x), read(y); addedge(x, y); } for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i);//常规操作tarjan for (int i = 1; i &lt;= n; ++i) for (int j = head[i]; j; j = next[j]) if (c[to[j]] != c[i]) chudu[c[i]]++;//现在扫描所有点的出边,如果有指向不同的连通块的边就出度++. for (int i = 1; i &lt;= noc; ++i) { if (chudu[i]) continue;//现在统计出度为0的强连通分量,此时每个强连通分量都视为一个点. ans += members[i];//统计牛数 noz++; } if (noz &gt; 1)//如果有多个出度为0的群组,显然两边均无法成为所有牛的明星. cout &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; return 0; }欢迎批评和指正!","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"强连通分量","slug":"强连通分量","permalink":"http://yoursite.com/tags/强连通分量/"}],"author":"i-cookie"},{"title":"luogu P1020 导弹拦截","slug":"导弹拦截","date":"2019-07-29T15:36:33.000Z","updated":"2019-10-09T04:48:10.000Z","comments":true,"path":"2019/07/29/导弹拦截/","link":"","permalink":"http://yoursite.com/2019/07/29/导弹拦截/","excerpt":"","text":"题目描述某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 输入导弹依次飞来的高度（雷达给出的高度数据是≤50000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入格式1行，若干个整数（个数≤100000） 输出格式2行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 解决问题在luogu上这道题被加强过了,分为两问. 第一问显然,对于一套设备来说,它能防御的是一个不上升序列,也就是说,要求出一套设备最多能拦截多少导弹,只要在导弹序列中求出最长不上升子序列的长度就可以了.值得注意的一点是,数据范围不允许我们用n2做法求子序列,因此要采用二分查找的方式以nlogn的时间复杂度求解. 第二问这个问题可以在脑内想象一下. 现在有一列导弹飞来,高度有高有低.为了拦截导弹,第一颗导弹必须由第一套设备拦截下来,但是从此以后它就不能拦住比这一颗低的导弹了.如果之后有一颗比当前能拦截的高度还要高的导弹飞来,就只能启用一套新的设备来拦截它了.这些都是显而易见的.但是问题来了,如果一颗不是很高的导弹飞来,有不止一套设备能拦住它,那应该由谁来呢? 考虑我们现在所拥有的设备,每一台设备都可能在后面拦截很多导弹,但是每一台设备的”前途”是不一样的.显然,目前能拦截的高度最高的设备更有前途能拦截下以后的较高的导弹.而最高高度较低的设备就前途不如这一台好.从另一个角度来说,高度高的设备,如果拦截这一颗导弹,它的最高高度会下降很多,而高度较低的,则会下降较少,显然让较低的来比较划算.当然我们仅仅是在能拦截这颗导弹的设备范围内查找.为了提高效率,我们采用二分查找或者直接lower_bound来查找. 代码#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int n, h[100005], b[100005], target = 1, system[100005]; void findpos(int l, int r, int aim)//二分查找求最长不上升子序列 { int mid = (l + r) / 2; if(l == mid) { b[mid + 1] = aim; return; } if(aim &gt; b[mid]) { findpos(l, mid, aim); } else if(aim &lt;= b[mid]) { findpos(mid, r, aim); } } int main() { int qwq = 1, x; while (scanf(&quot;%d&quot;, &amp;x) == 1) { h[qwq] = x; qwq++; } qwq--; b[1] = h[1]; for (int i = 2; i &lt;= qwq; i++) { if(h[i] &lt;= b[target]) b[++target] = h[i]; else findpos(0, target, h[i]); } cout &lt;&lt; target &lt;&lt; endl; /*********以上第一问,以下第二问*********/ int nos = 1;//nos,即number of systems,目前已经采用的设备台数 sys[1] = h[1];//sys数组存放每一台设备的最高高度 for(int i = 2; i &lt;= qwq; i++) { if(h[i] &gt; sys[nos]) {//因为新设备是因为导弹太高而被启用,所以新设备的最高高度一定是最大的 nos++; sys[nos] = h[i]; }//启用更新的新设备 else { int t = lower_bound(sys + 1, sys + 1 + nos, h[i]) - sys;//找到能拦截的高度最小的设备 sys[t] = h[i]; } } cout &lt;&lt; nos &lt;&lt; endl; return 0; } 欢迎批评和指正!","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}],"author":"i-cookie"},{"title":"The captain题目回顾","slug":"THE CAPTAIN","date":"2019-07-29T08:14:40.000Z","updated":"2019-10-09T04:46:30.000Z","comments":true,"path":"2019/07/29/THE CAPTAIN/","link":"","permalink":"http://yoursite.com/2019/07/29/THE CAPTAIN/","excerpt":"","text":"题面给定平面上的n个点，定义(x1,y1)到(x2,y2)的费用为min(|x1-x2|,|y1-y2|)，求从1号点走到n号点的最小费用。 分析首先,直接走过去花费肯定是min(…). 画图可以发现,在1,n围成的矩形中,如果有其他点,那么通过其他点走过去一定不会更劣(至少不亏).而且最短路显然会选择更短的路线(废话)所以两个点之间可以建两条边也无所谓. 所以,我们按照x排序,相邻的点之间连边,再按照y排序,相邻的点之间连边,然后跑最短路就好了!","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"}],"author":"i-cookie"},{"title":"7.29 \"简单\"(大嘘)DP","slug":"7.29 简单(大嘘)DP","date":"2019-07-29T03:32:05.000Z","updated":"2019-10-09T04:44:28.000Z","comments":true,"path":"2019/07/29/7.29 简单(大嘘)DP/","link":"","permalink":"http://yoursite.com/2019/07/29/7.29 简单(大嘘)DP/","excerpt":"","text":"今天是真的头疼T1问题有n个电线杆,第i个高度为h[i],在相邻的电线杆之间造电线需要的价值是abs(h[i]-h[i-1]) * C.为一根电线杆增加X高度的代价是X²,最小化代价和 n &lt;= 10^5,h[i],C[i] &lt;= 100; 解法设f[i][j]表示 T2问题求有多少长度为N的排列,使得每个数要么比旁边两个都大,要么比旁边两个都小. N &lt;= 5000 解法f[i][j]表示长度为i,最后一个数是j,且该排列p中p[i-1]&gt;p[i]的合法方案数,g[i][j]表示长度为i,最后一个数是j,且排列中p[i-1]&lt;p[i]的合法方案数.则f[i][j]=g[i][i-j+1]. T3问题有n个人参加比赛,第i个人说:有ai个人比我分数高,有bi个人比我分数低,可以有相同分数,问最多多少人说真话 n &lt;= 100000 解法一个人说真话代表ai+1搭配n-bi的人的分数都是一样的.如果我们把它看成一段线段,那么在这n条线段中,相交且不重合的线段一定不能同时成为真话.所以问题就转化为选出尽量多的不想交或完全重合的线段, T4问题祖玛,消掉的条件是个数&gt;=k,给出初始局面,要求插入一些颜色的尽可能少的球,使得原始局面依次插入球后全部消掉 N &lt;= 100 解法看起来就很像区间DP,f[l][r]表示将[l,r]消掉需要的最少球数.通常选择[l,r]之间的k,先消掉[l,k],再消[k,r].但是因为消掉以后两端会接在一起,所以普通的区间DP无法完成. 我们可以人为规定从左到右消掉序列.考虑一段区间的左边第一个数可能是怎么消掉的. 人为直接加球消掉 后面的消掉以后这个球和后面的拼在一起消掉了 f[i][j][k]表示消掉[i,j],前面已经插入了k个和a[l]一样的球的最小花费 转移: f[l][r][k] = f[l][x][k] + f[x+1][r][0] f[l][r][k] = f[l][r][k-1] + 1 f[l][r][k] = f[l+1][x-1][0] + f[x][r][k+1]T5问题有一个人在2 * n的网格上种蘑菇,(i,j)位置上每单位时间会增长v[i,j]的蘑菇.一个人从(1,1),每单位时间移动一个格子,且访问每个格子一次且仅一次,求他最多采多少蘑菇解法本题首先要注意的是经过每个点一次且仅一次.对于任意一个前缀,它的横向走的步数应该少于纵向走的步数. 设f[i][0]表示按照”蛇形”走完了前i格,f[i][1]表示按照U形走完了前i格. T6问题一开始有一个全部都是0的长度为n的序列. 现在要对这个序列进行若干轮操作,每一轮你都要选择这个序列的一个权值相同的连续子序列,然后把除了第一个和最后一个之外的数全部+1. 在进行了操作后,这个序列的若干项遗失了.问有多少种填数方法,使得它是合法的. 1 &lt;= n &lt;= 10000, 1 &lt;= h[i] &lt;= 10000 解法考虑逆操作,选择[l,r],将除了头尾之外的都-1,要求-1后这一段权值相等. T7问题求n个点(带标号)的连通图个数,答案对998244353取模 解法如果不要求连通(任意图),那么就是2^C(n,2)次.可以通过减去不合法的来求出连通图的个数.不合法就意味着图被分成了若干块.令f[n]表示大小为n的连通图个数.则f[n] = 2^C(n,2)-不连通图个数(g[n]).如何求g[n]呢.考虑1号点所在连通块大小为i,则剩下了n-i个点与这个块不连通.这i个点内部连边方案为f[i]种.i和n-i个点之间连边方案为1,即不连边.剩下的n-i个点则随意连都不影响答案,那么其连边方案为2^C(n-i,2)种.然而本题要求有编号,这i个点不一定是2到i号(提前已指定1号点的联通块大小为i).,因此还要乘上C(n-i,i-1). T8问题求n个点(带标号)的欧拉图个数,答案对998244353取模.※欧拉图:连通的存在一条欧拉回路的图 解法容斥,先求出每个点度数都是偶数的图的个数,然后再减去不连通的这种图的个数. 先取出一个点,剩下n-1个点内部随便连的话将成为2^C(n-1,2).但是这其中将会有一些度数为奇数的点,这时候就将拿出来的1号点向那些点连边.这时候1号点呢?一定是偶数度数.因为此时其他所有的点都是偶数度数,所以1不可能是奇数度数.设f[n]表示大小为n,欧拉图的方案数.f[n] = 2^[(n-1) * (n-2) / 2]-g[n].g[n]=Σi from 1 to n-1,g[i] * (n - i - 1) * (n - i - 2) * C( T9问题有n个小朋友在玩游戏.有一个环,环上有2^m个位置,标号从0开始. 这n个小朋友每个人在时刻0在某个位置上,每隔一秒,他们都会顺时针往下移动一位.即如果原来在位置x,下一秒会在位置(x+1)%2^m. 问,在[1,T]这些时刻里,有多少个时刻他们的位置编号的异或和为S? n &lt;= 10^5,m &lt;= 50,T &lt;= 10^16,S &lt;= 2^m. 解法假设T=2^m - 1,f[i][j]表示已经确定了T的后i位,有j个数进位了(由此可知有哪些仅为了,因为进位的一定是%2^m的前j位)的方案数.枚举T的第i位是0还是1,就可以知道每个数在这一位是什么,检验一下XOR起来是不是S的这一位,是就合法,否则不合法….████████████████[数据删除]","categories":[{"name":"课堂笔记","slug":"课堂笔记","permalink":"http://yoursite.com/categories/课堂笔记/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}],"author":"i-cookie"},{"title":"蒟蒻的第一篇题解luogu P3078/P5019/P1969","slug":"积木大赛系列","date":"2019-07-28T06:24:00.000Z","updated":"2019-10-09T04:40:06.000Z","comments":true,"path":"2019/07/28/积木大赛系列/","link":"","permalink":"http://yoursite.com/2019/07/28/积木大赛系列/","excerpt":"","text":"三倍经验NOIP2018 铺设道路 NOIP2013 积木大赛 题意给出一个长度为n的数列A,每次可以任选一段区间[l,r],使A[l]到A[r]全部-1,最终将整个序列减到0,求最小操作次数. 分析一开始的序列可以转化成这个样子.每一次选取一段区间-1,可以怎么操作呢? 1.暴力枚举区间,然后暴力-1 emmm,时间复杂度:O(不能过),pass.※期望得分:0; 2.线段树 emmmmmmm,勇气可嘉,但是还要动动脑子,不要一看到区间加减就开始上奇怪的数据结构. 3.O(n)递推 其实这是我在做NOIP2013/2018的T1时的做法.看图: 很容易可以看出,两个红色框部分是不能一起减掉的,只能两堆分开减,因为中间有一个低谷将两边的堆隔开,那么在最优情况下,这个低谷一定比两堆更早减为0,于是两堆注定隔开.但是下面蓝色框的部分就属于两堆的公共部分,只要在减其中一堆时顺便减掉它就好了.而且,加入我们把序列的第n+1位看成0的话,它就相当于一个一低到底的低谷,有了这些,我们就可以得出以下思路: 如图,每当我们遇到一个低谷,我们就将目前路过的这座山峰,也就是上一个峰顶-这一个谷底的高度减去,这样最后当遇到第n+1位的0时,一定能将剩下所有的高度减掉.这样就保证了只有被迫隔开的山峰是需要分别减去的,而公共部分的次数都没有浪费.不明白的话可以画图模拟一下. 核心代码: long long h[N], ans//A序列,答案; for (int i = 1; i &lt;= n ; ++i) { if (h[i] &gt; h[i + 1]) {//当遇到峰顶时记录下现在的高度 long long temp = h[i]; while (h[i] &gt; h[i + 1]) //一路找到谷底 i++; ans += temp - h[i];记录答案 } } 这样就可以解决了! ※期望得分:100 4.差分 差分是一个绝妙的思想,对A建立差分数组B,差分数组意味着B[i]=a[i]-a[i-1],也就是将A序列每一位和前一位的差记录下来. 如果要实现区间[l,r]-1,我们只需要B[l]-1,B[r+1]+1就可以了(想一想,为什么) 于是这个A序列就变成了B序列.要想让A序列归零,我们就要让B序列归零(想一想,是不是).显然,B中的每一个正数,后面都有负数与它对应,因此我们只需要将这个序列中所有的正数加起来,就是我们操作的总次数! 核心代码: long long A[N], B[N], ans; int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; A[i]; B[i] = A[i] - A[i - 1]; if (B[i] &gt; 0) ans += B[i]; } cout &lt;&lt; ans &lt;&lt; endl; return 0; } ※期望得分:100 最后还有一句话要提醒: 三年OI一场空,不开long long见祖宗欢迎批评和指正!","categories":[{"name":"问题回顾","slug":"问题回顾","permalink":"http://yoursite.com/categories/问题回顾/"}],"tags":[{"name":"递推","slug":"递推","permalink":"http://yoursite.com/tags/递推/"}],"author":"i-cookie"},{"title":"经典模型——并查集解决区间/树链染色问题","slug":"并查集染色问题","date":"2019-07-27T06:35:24.000Z","updated":"2019-10-09T04:34:58.000Z","comments":true,"path":"2019/07/27/并查集染色问题/","link":"","permalink":"http://yoursite.com/2019/07/27/并查集染色问题/","excerpt":"","text":"蒟蒻的第一篇blog 模型背景：已知一个长度为n的序列，开始时序列的每一个元素都没有颜色（0），现进行m次操作，第i次操作将一段区间[l,r]中还未被染色的点(即a[i]=0的点)染成颜色i.问m次操作后这个区间长什么样子,并将它输出来. 数据规模约定:对于100%的数据,n,m&lt;=10^6 问题解决 我会nm暴力! 对于每一个操作i,暴力扫描[l,r],染色,最后输出. ※期望得分:10. 并查集!没想到吧 用并查集来维护从节点i往后的区间[i,n]中第一个0出现的位置,也就是i之后第一个还未被染色的点的位置. 这是怎么做到的呢? 一开始每个节点的father显然指向自己(所有点都没染色).如果这个点被染了色,就将它与它的右边第一个点union起来,即father[i] = father[i+1].比如: 经过几次之后的染色以及一番奇妙的路径压缩,序列将形成类似这种样子 这样,不就给下一次的操作省时间了吗,不就能一跳就跳到下一个0的地方染色了吗(欣喜) 核心代码: int findfather(int x) {//找下一个为0的点,顺便路径压缩 if (father[x] != x) father[x] = findfather(father[x]); return father[x]; } inline int combine(int x, int y) {//union int fx = findfather(x); int fy = findfather(y); if (fx != fy) father[fx] = fy; return; } int main() { /*读入等操作略*/ for (int i = 1; i &lt;= m; ++i) {//染色 for (int j = findfather(l); j &lt;= r; j = findfather(j)) { color[j] = i; } } /*输出操作略*/ } 怎么样,是不是很好懂呢? 然而,如果是要对树上的链进行染色的话,又该如何做呢? 这不就是树链剖分吗,上树剖啊 嗯,看起来就好像 【模板】树链剖分 的简化版.但是请回头看一眼数据范围.嗯,由于树剖的时间瓶颈在于线段树,树剖显然无法解决10^6级别的数据 期望得分:80. 并查集!没想到吧 对于树上的一条链(u,v),除了通过树链剖分来处理以外,我们还可以通过将这条链分割成(u,LCA),(LCA,v)来解决.类比之前对于一段序列的做法,我们可以改进出这样的做法: 问题解决在上一个模型中,我们发现了一种从一个点直接跳到下一个未染色的点的方法,那就是用并查集+路径压缩不断往右指.这个问题也一样.当一个点被染色时,我们可以将它的并查集数组指向它的父节点(即father[i]=fa[i],father[i]是i节点的并查集数组,fa[i]是它在题目中树上的父亲节点). 接下来就可以类比之前的问题了.若要给(3,5)染色,就由深度大的开始往上跳,不过这个跳是findfather那种跳(雾). 问题解决了吗?实际跳的时候会发现,它可能会跳到LCA以上的地方! 你会发现,如果2之前被染过色,那么路径压缩的时候会直接将3的father连到1上! 因此需要加一些特判,不让它往高处跳. 还有不懂的地方的话,就来看代码吧XD: /*我个人比较喜欢借助树链剖分来求LCA,也可以采用其他方法*/ int findfather(int x) //略 inline void combine(int x, int y) //略 inline int LCA(int x, int y) //略 inline void paint(int x, int y, int c) { int lca = LCA(x, y); while (x != y) { if (dep[x] &lt; dep[y]) swap(x, y);//每次让深度大的向上跳 x = dep[findfather(x)] &lt; dep[lca] ? lca : father[x];//特判,阻止X往上方跳 col[x] = c, combine(x, fa[x]); } return; } 这样问题就解决了! 欢迎指正和批评!","categories":[{"name":"经验总结","slug":"经验总结","permalink":"http://yoursite.com/categories/经验总结/"}],"tags":[{"name":"树形结构","slug":"树形结构","permalink":"http://yoursite.com/tags/树形结构/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/并查集/"}],"author":"i-cookie"}]}